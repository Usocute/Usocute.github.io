{
    "version": "https://jsonfeed.org/version/1",
    "title": "尺萤之光",
    "description": "一个收藏回忆记录成长的地方...",
    "home_page_url": "https://miraitowa.cc",
    "items": [
        {
            "id": "https://miraitowa.cc/post/fba23db0.html",
            "url": "https://miraitowa.cc/post/fba23db0.html",
            "title": "leetcode-罗马数字转整数",
            "date_published": "2021-03-28T12:46:10.812Z",
            "content_html": "<h2 id=\"罗马数字转整数\">罗马数字转整数</h2>\n<p><strong>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符          数值</span><br><span class=\"line\">I             1</span><br><span class=\"line\">V             5</span><br><span class=\"line\">X             10</span><br><span class=\"line\">L             50</span><br><span class=\"line\">C             100</span><br><span class=\"line\">D             500</span><br><span class=\"line\">M             1000</span><br></pre></td></tr></table></figure>\n<p><strong>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 <code>1</code>。<code>12</code> 写做 <code>XII</code> ，即为 <code>X + II</code> 。 <code>27</code> 写做  <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</strong></p>\n<p><strong>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 <code>4</code> 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 <code>1</code> 在数字 <code>5</code> 的左边，所表示的数等于大数 <code>5</code> 减小数 <code>1</code> 得到的数值 <code>4</code> 。同样地，数字 <code>9</code> 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</strong></p>\n<p><code>I</code> 可以放在 <code>V (5)</code> 和 <code>X (10)</code> 的左边，来表示 <code>4</code> 和 <code>9</code>。<br>\n<code>X</code> 可以放在 <code>L (50)</code> 和 <code>C (100)</code> 的左边，来表示 <code>40</code> 和 <code>90</code>。 <br>\n<code>C</code> 可以放在 <code>D (500)</code> 和 <code>M (1000)</code> 的左边，来表示 <code>400</code>和 <code>900</code>。<br>\n给定一个罗马数字，将其转换成整数。输入确保在 <code>1</code> 到 <code>3999</code>的范围内。</p>\n<h4 id=\"示例-1\">示例 1:</h4>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;III&quot;</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"示例-2\">示例 2:</h4>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入: &quot;IV&quot;</span></span><br><span class=\"line\"><span class=\"section\">输出: 4</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"示例-3\">示例 3:</h4>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">输入: &quot;IX&quot;</span></span><br><span class=\"line\"><span class=\"section\">输出: 9</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"示例-4\">示例 4:</h4>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;LVIII&quot;</span></span><br><span class=\"line\">输出: <span class=\"number\">58</span></span><br><span class=\"line\">解释: L = <span class=\"number\">50</span>, V= <span class=\"number\">5</span>, III = <span class=\"number\">3.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"示例-5\">示例 5:</h4>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;MCMXCIV&quot;</span></span><br><span class=\"line\">输出: <span class=\"number\">1994</span></span><br><span class=\"line\">解释: M = <span class=\"number\">1000</span>, CM = <span class=\"number\">900</span>, XC = <span class=\"number\">90</span>, IV = <span class=\"number\">4.</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"提示：\">提示：</h4>\n<ul>\n<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n<li>IC 和 IM 这样的例子并不符合题目要求，<code>49</code> 应该写作 <code>XLIX</code>，<code>999</code> 应该写作 <code>CMXCIX</code> 。</li>\n<li>关于罗马数字的详尽书写规则，可以参考<a href=\"https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article\">罗马数字 - Mathematics</a>。</li>\n</ul>\n<h2 id=\"解题思路\">解题思路</h2>\n<p><strong>仔细分析罗马数字的规律，会发现，罗马字母(<code>XII</code>)正常是从左到右按从大到小排列，当代表小数字(<code>I</code>)的字母在代表大数字的字母(<code>V</code>)左边时，这意味着两个字母代表一个数，而且是大数字减小数字的最终结果（<code>V-I</code>）。</strong></p>\n<p><strong>所以，在做计算时，只需遍历判断下标为<code>i</code>的字母是否大于下标为<code>i+1</code>的字母，如果大于，则相加，如果小于，则需要减去当前这个数。</strong></p>\n<h4 id=\"代码\">代码</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> romanToInt = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;I&#x27;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;V&#x27;</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;X&#x27;</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;L&#x27;</span>: <span class=\"number\">50</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;C&#x27;</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;D&#x27;</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;M&#x27;</span>: <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>, len=s.length; i&lt;len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> left = s[i],</span><br><span class=\"line\">            right = s[i+<span class=\"number\">1</span>],</span><br><span class=\"line\">            newNum = obj[left]&lt;obj[right]? <span class=\"number\">0</span> - obj[left]: obj[left];</span><br><span class=\"line\">        num += newNum</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "leetcode",
                "javascript"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/7292aa95.html",
            "url": "https://miraitowa.cc/post/7292aa95.html",
            "title": "JavaScript高级⑥-存储(cookie)",
            "date_published": "2021-03-28T10:00:00.000Z",
            "content_html": "<h2 id=\"sessionStorage、localStorage和cookie\">sessionStorage、localStorage和cookie</h2>\n<h3 id=\"相同点\">相同点</h3>\n<ul>\n<li>都是保存在浏览器端、且同源的。</li>\n</ul>\n<h3 id=\"区别\">区别</h3>\n<ol>\n<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。<code>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</code>。</li>\n<li>存储大小限制也不同，<code>cookie数据不能超过4K（小于4096）</code>，同时因为每次http请求都会携带cookie、所以<code>cookie只适合保存很小的数据，如会话标识</code>。<code>sessionStorage和localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到<code>5M或更大</code>。</li>\n<li>数据有效期不同，<code>sessionStorage</code>：仅在<code>当前浏览器窗口关闭之前</code>有效；<code>localStorage</code>：<code>始终有效</code>，窗口或浏览器关闭也一直保存，因此用作持久数据；<code>cookie</code>：只<code>在设置的cookie过期时间之前有效</code>，即使窗口关闭或浏览器关闭。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>\n<li><code>web Storage</code>支持事件通知机制，可以将数据更新的通知发送给监听者。</li>\n<li><code>web Storage</code>的api接口使用更方便。</li>\n<li><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li>\n</ol>\n<h2 id=\"Cookie\">Cookie</h2>\n<ol>\n<li>\n<p>什么是Cookie：cookie是存储于用户计算机中的变量。每当该计算机通过浏览器请求某个页面时，就会发送这个cookie。我们可以使用JavaScript来创建和获取cookie的值。</p>\n</li>\n<li>\n<p>cookie的存储形式：<code>键值对</code>，如：<code>name=张三</code></p>\n</li>\n<li>\n<p>使用JS创建Cookie的格式：<code>document.cookie = “name=张三”;</code><br>\n还可以为cookie添加一个过期时间（UTC或GMT,默认情况下，cookie在浏览器关闭时删除）。如：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.cookie = “name=张三;</span><br><span class=\"line\">expires=Thu, <span class=\"number\">18</span> Dec <span class=\"number\">2019</span> <span class=\"number\">12</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> GMT”;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用JS读取Cookie的格式： <code>var X = document.cookie;</code></p>\n</li>\n<li>\n<p>修改Cookie：JS中修改cookie类似于创建cookie，旧的cookie会被覆盖掉。</p>\n</li>\n<li>\n<p>删除Cookie：只需设置expires参数为以前的时间即可。<br>\n如：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.cookie = “name=张三; </span><br><span class=\"line\">expires=Thu, <span class=\"number\">18</span> Dec <span class=\"number\">2019</span> <span class=\"number\">12</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> GMT”;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Cookie的缺点：</p>\n<ol>\n<li>Cookie可能被用户禁用。</li>\n<li>同一个页面被不同浏览器访问时，浏览器之间保存的Cookie不能相互访问。</li>\n<li>每个Cookie都保存在客户端硬盘文件上，可能会被删除。</li>\n<li>Cookie安全性不高，所有Cookie都是以纯文本形式记录于文件中。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Web存储机制\">Web存储机制</h2>\n<blockquote>\n<ul>\n<li>HTML5提供了一种新的对象<code>Storage</code>，类似于<code>String</code>、<code>Number</code>、<code>Object</code>。通过Storage对象提供的方法和属性来对数据进行增删改查。</li>\n<li>html5中的<code>Web Storage</code>包括了两种存储方式：<code>localStorage</code>和<code>sessionStorage</code>。两者都是用来存储客户端临时信息的对象。</li>\n<li><code>sessionStorage</code>用于本地存储一个会话（<code>session</code>）中的数据，这些数据只有在同一个会话中的页面才能访问，并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅是会话级别的存储。只允许同一窗口访问。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。同源可以读取并修改localStorage数据。并且他们储存的对象类型均为字符串类型；我们将数据以键值对的形式保存到Storage对象里，通过Storage对象提供的方法进行数据操作。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 增：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</span></span><br><span class=\"line\">Storage.setItem()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 删</span></span><br><span class=\"line\"><span class=\"comment\">// 清空存储中的所有键名</span></span><br><span class=\"line\">Storage.clear()</span><br><span class=\"line\"><span class=\"comment\">// 接受一个键名作为参数，并把该键名从存储中删除。</span></span><br><span class=\"line\">Storage.removeItem()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 改：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</span></span><br><span class=\"line\">Storage.setItem()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 查</span></span><br><span class=\"line\"><span class=\"comment\">// 接受一个键名作为参数，返回键名对应的值</span></span><br><span class=\"line\">Storage.getItem()</span><br><span class=\"line\"><span class=\"comment\">// 接受一个数值 n 作为参数，并返回存储中索引为n 的键名</span></span><br><span class=\"line\">Storage.key()</span><br><span class=\"line\"><span class=\"comment\">// 返回存储的数据量</span></span><br><span class=\"line\">Storage.length</span><br></pre></td></tr></table></figure>\n<h2 id=\"sessionStorage对象\">sessionStorage对象</h2>\n<ul>\n<li>sessionStorage对象存储某个特定会话的数据，该数据只保持到浏览器关闭（类似于cookie）。</li>\n<li>存储在sessionStorage对象中的数据可以跨越页面刷新而存在。部分浏览器也支持在浏览器崩溃的情况下重启仍然可用（如：Firefox和WebKit等，但是IE不支持）。</li>\n<li>sessionStorage对象其实是Storage对象的一个实例，具体方法如下：\n<ol>\n<li>sessionStorage.length:获取存储在Storage对象中的数据的数量，是一个只读属性。</li>\n<li>sessionStorage.key():接受一个数值 n 作为参数，并返回存储中索引为n 的键名。</li>\n<li>sessionStorage.getItem():接受一个键名作为参数，返回键名对应的值。</li>\n<li>sessionStorage.setItem()：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>\n<li>sessionStorage.clear()：清空存储中的所有键名。</li>\n<li>sessionStorage.removeItem()：接受一个键名作为参数，并把该键名从存储中删除。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"globalStorage\">globalStorage</h2>\n<blockquote>\n<p>globalStorage在浏览器关闭以后，使用globalStorage存储的信息仍能够保留下来，localStorage一样，域中任何一个页面存储的信息都能被所有的页面共享。</p>\n</blockquote>\n<ul>\n<li>基本语法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在developer.mozilla.org下面所有的子域都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;developer.mozilla.org&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在mozilla.org域名下面的所有网页都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;mozilla.org&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在.org域名下面的所有网页都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;org&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在任何域名下的任何网页都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：globalStorage对象已经被localStorage对象取代。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"localStorage对象\">localStorage对象</h2>\n<ul>\n<li>\n<p>localStorage的优势：</p>\n<ol>\n<li>localStorage拓展了cookie的4k限制。</li>\n<li>localStorage可用将第一次请求的数据直接存储到本地，相当于5M大小的针对于前端页面的数据库，相比于cookie可用节约带宽，但是只有在高版本浏览器中才支持。</li>\n</ol>\n</li>\n<li>\n<p>localStorage的局限：</p>\n<ol>\n<li>只有在IE8以上浏览器才支持localStorage的存储功能。</li>\n<li>目前所有浏览器都会把localStorage的值类型限定为string，这需要我们转换为JSON对象类型。</li>\n<li>localStorage在浏览器的隐私模式下不可读取。</li>\n<li>由于localStorage在本质上是对字符串的读取，所以如果存储的内容较多，会消耗掉内存空间，导致页面卡顿，加载速度减慢。</li>\n<li>localStorage不能被爬虫抓取到。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>localStorage对象的具体方法与sessionStorage的方法一致。</p>\n</blockquote>\n",
            "tags": [
                "js",
                "js高级",
                "cookie"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/a1736a1e.html",
            "url": "https://miraitowa.cc/post/a1736a1e.html",
            "title": "JavaScript高级⑤-高级函数",
            "date_published": "2021-03-25T10:00:00.000Z",
            "content_html": "<h2 id=\"安全的类型检测\">安全的类型检测</h2>\n<blockquote>\n<p><code>在JS中，内置的类型检测机制有typeof和instanceof</code>，但是这两个关键字<code>并非完全可靠</code>。所以我们可以使用<code>Object的toString()方法</code>以保证返回一个<code>[object XXX]</code>格式的字符串。这样就可以创建一个函数来判断对象的类型。</p>\n</blockquote>\n<h2 id=\"作用域安全的构造函数\">作用域安全的构造函数</h2>\n<ul>\n<li>创建一个作用域安全的构造函数，就是让this对象指向正确的实例对象。</li>\n<li>首先使用<code>instanceof</code>方法判断this对象是否为正确类型的实例，如果不是，就创建一个新的实例并返回。</li>\n</ul>\n<h2 id=\"惰性载入函数\">惰性载入函数</h2>\n<p><strong>惰性载入函数表示函数执行的分支仅会发生一次，实现惰性载入函数的方式有两种。</strong><br>\n1. 第一种，在函数被调用时再处理。在第一次调用时，该函数会覆盖为另一个按合适方式执行的函数，这样任何对函数的调用都不会再经过执行的分支了。<br>\n2. 第二种，在声明函数时就制定适当的函数。这样在第一次调用函数时就不会损失性能，而在代码首次加载时会损失一点儿性能。</p>\n<h2 id=\"函数绑定\">函数绑定</h2>\n<blockquote>\n<p>JS与DOM交互中经常需要使用函数绑定，定义一个函数然后将其绑定到特定DOM元素或集合的某个事件触发程序上，也经常与事件处理程序一起使用，以便把函数作为变量传递的同时保留代码执行环境。</p>\n</blockquote>\n<h2 id=\"重复的定时器\">重复的定时器</h2>\n<p><strong>我们通常使用<code>setInterval</code>方式来实现时间间隔会出现两个问题：</strong><br>\n1. 某些间隔会被跳过。<br>\n2. 多个定时器的代码执行时，间隔可能会有误差。<br>\n<strong>所以我们可以使用<code>setTimeout</code>方式来完善该功能。</strong></p>\n<h2 id=\"函数节流\">函数节流</h2>\n<ul>\n<li>定时器不仅可以用来定时，还可以用来缓解浏览器的压力。浏览器在执行DOM操作的时候，就会使用更多的内存和CPU。连续使用过多的DOM操作会导致浏览器崩溃。</li>\n<li>函数节流的基本思想就是，某些代码不可以在没有间断的情况下连续重复使用。也就是说，第一次调用函数就创建一个定时器，在指定的时间间隔之后才能再次运行。当第二次调用该函数时，就会清除前一次的定时器并设置一个。目的就是为了保证每次执行函数时有一段时间的间隔。</li>\n</ul>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/faefd80d.html",
            "url": "https://miraitowa.cc/post/faefd80d.html",
            "title": "JavaScript高级④-AJAX与JSON",
            "date_published": "2021-03-22T10:00:00.000Z",
            "content_html": "<h2 id=\"AJAX介绍和创建XHR对象\">AJAX介绍和创建XHR对象</h2>\n<blockquote>\n<p>AJAX:异步 JavaScript 和 XML。简短地说，在不重载整个网页的情况下，AJAX通过后台加载数据，并在网页上进行显示。</p>\n</blockquote>\n<p><strong>AJAX包括以下几个步骤：</strong></p>\n<ol>\n<li>创建AJAX对象；</li>\n<li>发出HTTP请求；</li>\n<li>接收服务器传回的数据；</li>\n<li>更新页面数据；</li>\n</ol>\n<ul>\n<li><strong>Ajax的工作原理如图所示：</strong><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-javascript-AJAX-JSON-img1.png\" alt=\"AJAX\"></li>\n</ul>\n<blockquote>\n<p>总结：</p>\n</blockquote>\n<ul>\n<li>AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后再进行处理。</li>\n<li><code>AJAX技术的核心就是XMLHttpRequest对象</code>（简称：XHR），这是微软首次引入的一个特性，其他浏览器厂商后来都提供了相同的实现。</li>\n<li>IE5中的XHR对象是通过ActiveX对象实现的，而IE7+及其他标准浏览器都支持原生的XHR对象。</li>\n<li>创建一个XHR对象，也叫做实例化一个XHR对象，因为XMLHttpRequest()是一个构造函数。</li>\n</ul>\n<h2 id=\"XHR的用法介绍\">XHR的用法介绍</h2>\n<ol>\n<li><code>open()</code>方法：设置:  HTTP方法和要获取资源的URL;</li>\n<li><code>send()</code>方法：发送请求：</li>\n<li><code>onload</code>属性：设置:  成功获取数据后将要运行的函数;</li>\n<li><code>onerror</code>属性：设置:  出现错误后将要运行的函数;</li>\n<li><code>responseText</code>属性：设置:  存储异步请求响应的文本;</li>\n</ol>\n<h2 id=\"HTTP头部信息\">HTTP头部信息</h2>\n<blockquote>\n<p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。XHR对象也提供了操作这两种头部信息（请求头和响应头）的方法。</p>\n</blockquote>\n<ol>\n<li><code>Accep</code>t：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</li>\n<li><code>Accept-Charset</code>：浏览器告诉服务器自己能接收的字符集。</li>\n<li><code>Accept-Encoding</code>：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）。</li>\n<li><code>Accept-Language</code>：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</li>\n<li><code>Cache-Control</code>：指定请求和响应遵循的缓存机制。</li>\n<li><code>Connection</code>：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1，它就表示持久连接。</li>\n<li><code>Cookie</code>：当前域名下的Cookie。</li>\n<li><code>Referer</code>： 浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL。</li>\n<li><code>User-Agent</code>：浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0</li>\n</ol>\n<h2 id=\"GET与POST请求\">GET与POST请求</h2>\n<ol>\n<li>由于<code>GET方式</code>在发送数据时是将参数拼接在URL上，<code>传输数据会受到URL长度的限制</code>，不同浏览器的长度限制不一样，所以<code>GET方式会受到参数大小的限制</code>，但是<code>POST方式没有参数大小的限制</code>。</li>\n<li>因为GET方式会将请求参数显示在地址栏上，而POST方式不会，所以<code>POST方式相对来讲更安全</code>。</li>\n<li><code>GET方式有缓存，而POST方式没有缓存</code>。</li>\n</ol>\n<h2 id=\"JavaScript中的跨域请求\">JavaScript中的跨域请求</h2>\n<ul>\n<li>受JS同源策略的影响，当在某一域名下请求其他域名，或在同一域名下请求不同端口的URL时，就会变成不被允许的跨域请求。127.0.0.1:8020</li>\n</ul>\n<h2 id=\"了解XDomainRequest对象\">了解XDomainRequest对象</h2>\n<blockquote>\n<p><code>XDomainRequest表示JavaScript和Ajax的跨域请求，在IE8+可以使用</code>。<br>\nXDomainRequest包含以下几个部分：</p>\n</blockquote>\n<ol>\n<li>事件\n<ol>\n<li><code>onload</code>事件：请求成功并返回对象时，被触发。</li>\n<li><code>onerror</code>事件：当跨域请求发生错误时，被触发。</li>\n<li><code>onprogress</code>事件：浏览器开始从服务器端接收数据时，被触发。</li>\n<li><code>ontimeout</code>事件：出现超时情况，被触发。</li>\n</ol>\n</li>\n<li>方法\n<ol>\n<li><code>abort</code>方法：终止等待send</li>\n<li><code>open(XDomainRequest)</code>方法：建立与服务器的链接</li>\n<li><code>send(XDomainRequest)</code>方法：传输一个字符串数据给服务器处理</li>\n</ol>\n</li>\n<li>属性\n<ol>\n<li><code>constructor</code>属性：返回一个对象的构造函数的引用</li>\n<li><code>contentType</code>属性：返回html请求或返回头部的content-type属性</li>\n<li><code>responseText</code>属性：以字符串形式返回请求的body内容</li>\n<li><code>timeout</code>属性：超时后返回的值。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"JSON数据\">JSON数据</h2>\n<blockquote>\n<p><code>JSON(JavaScript Object Notation</code>, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 <code>ECMAScript</code> (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>\n</blockquote>\n<p><strong>Json的语法可以表示成三种类型的值：</strong><br>\n1. 简单值：可以在Json中表示字符串、数值、布尔值和null，但是<code>不支持undefined</code>;<br>\n2. 对象：作为一种复杂数据结构，表示一种无序的键值对，每个键值对中的值既可以是简单值，也可以是复杂数据类型的值。<br>\n3. 数组：作为一种复杂数据结构，表示一种有序值的列表，可以通过数组索引访问其中的值。数组中的元素可以是任何类型：简单值、对象、数组均可。<br>\n<strong>如：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;World&#x27;</span>&#125;; </span><br><span class=\"line\"><span class=\"comment\">//这是一个对象，注意键名也是可以使用引号包裹的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"string\">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>;</span><br><span class=\"line\"> <span class=\"comment\">//这是一个 JSON 字符串，本质是一个字符串</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在Ajax中使用JSON数据\">在Ajax中使用JSON数据</h2>\n<ol>\n<li><code>JSON.parse()</code>：把Json格式的字符串转换为Json对象。</li>\n<li><code>JSON.stringify()</code>:把Json对象转换为Json格式的字符串。</li>\n</ol>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/bd399257.html",
            "url": "https://miraitowa.cc/post/bd399257.html",
            "title": "JavaScript高级③-匿名函数及函数操作",
            "date_published": "2021-03-20T10:00:00.000Z",
            "content_html": "<h2 id=\"匿名函数\">匿名函数</h2>\n<h3 id=\"工厂模式\">工厂模式</h3>\n<blockquote>\n<p>假如我们把猫看成是一类，都有名字和颜色的属性，那么，每一只猫就是这个类的实例，我们可以使用字面量方式定义对象：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat1 = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">&quot;大黄&quot;</span>,</span><br><span class=\"line\">  color:<span class=\"string\">&quot;黄色&quot;</span>,</span><br><span class=\"line\">  say:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">&quot;小黑&quot;</span>,</span><br><span class=\"line\">  color:<span class=\"string\">&quot;黑色&quot;</span>,</span><br><span class=\"line\">  say:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这样创建对象，一是创建对象比较麻烦，二是实例与原型（猫类）之间，没有任何联系。</li>\n<li>为了简化代码书写，我们可以写一个函数批量创建对象，也就是使用<code>“工厂模式”</code>：<br>\n<strong>（工厂模式中的函数，首字母大写）：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n,c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name:n,</span><br><span class=\"line\">        color:c,</span><br><span class=\"line\">        say:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>生成实例对象，就等于是在调用函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat1 = Cat(<span class=\"string\">&quot;大黄&quot;</span>,<span class=\"string\">&quot;黄色&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = Cat(<span class=\"string\">&quot;小黑&quot;</span>,<span class=\"string\">&quot;黑色&quot;</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样代码虽然简单了，但是实例之间还是没有什么联系。</p>\n</blockquote>\n<h3 id=\"构造函数\">构造函数</h3>\n<ul>\n<li>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</li>\n<li>所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</li>\n<li>构造函数首字母大写，没有return语句，没有显式地创建对象。</li>\n<li>构造函数中的this，指向的是实例化的对象<br>\n<strong>例如：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n,c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name=n;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color=c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成实例对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">&quot;大黄&quot;</span>,<span class=\"string\">&quot;黄色&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">&quot;小黑&quot;</span>,<span class=\"string\">&quot;黑色&quot;</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1.constructor == Cat); <span class=\"comment\">//true</span></span><br><span class=\"line\">alert(cat2.constructor == Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</li>\n<li>instanceof不认为基本类型值的变量是对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> txt=<span class=\"string\">&#x27;adsdf&#x27;</span>;</span><br><span class=\"line\">alert(txt <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>);<span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> age=<span class=\"number\">123123</span>;</span><br><span class=\"line\">alert(age <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span>);<span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> re=<span class=\"regexp\">/\\d/</span>;</span><br><span class=\"line\">alert(re <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[];</span><br><span class=\"line\">alert(arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>)<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式和原型链\">原型模式和原型链</h3>\n<ul>\n<li>每类对象的实例对象，都有可能会有一些相同的属性，或者相同的功能，如果都写在构造函数上，会造成重复的内容，占用更多的内存。</li>\n<li>为了解决这种代码的重复</li>\n<li>构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</li>\n<li>我们可以把那些不变的属性和方法，直接定义在prototype对象上。让实例对象共享其属性和方法。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cat.protoType.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cat1.say()<span class=\"comment\">//miao</span></span><br><span class=\"line\">cat2.say()<span class=\"comment\">//miao</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有的函数都是 Function 的实例。在构造函数上都有一个原型属性—prototype，prototype也是一个对象；这个对象上有一个 constructor 属性，该属性指向的就是构造函数。</li>\n<li>而实例对象上有一个_proto_属性，该属性也指向原型对象，该属性不是标准属性，不可以用在编程中，该属性用于浏览器内部使用。</li>\n</ul>\n<h3 id=\"组合使用构造函数模式和原型模式\">组合使用构造函数模式和原型模式</h3>\n<ol>\n<li>\n<p>构造函数与原型模式组合的模式是目前使用最广泛、认同度最高的一种创建定义类型的方法。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。</p>\n</li>\n<li>\n<p>每个实例都会有自己的一份实例属性的副本，同时共享着对方法的引用，最大限度节省内存。同时，这种组合模式还支持向构造函数传递参数，集合了两种模式的优点。</p>\n</li>\n</ol>\n<h3 id=\"动态原型模式\">动态原型模式</h3>\n<ul>\n<li>动态原型模式就是把所有信息都封装在构造函数中，通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</li>\n</ul>\n<h3 id=\"寄生构造函数模式\">寄生构造函数模式</h3>\n<ul>\n<li>寄生构造函数模式的基本思想，是创建一个用于封装创建对象的函数。主要用于创建一个自定义类型的函数。</li>\n</ul>\n<h3 id=\"稳妥构造函数模式\">稳妥构造函数模式</h3>\n<ul>\n<li>稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。适合在一些安全的环境中（禁用this和new的环境），或者防止数据被其他应用程序调用时使用。</li>\n<li>稳妥构造函数遵循与寄生构造函数类似的模式，只是有两点不同：\n<ol>\n<li>新创建对象的实例方法不引用this；</li>\n<li>不使用new调用构造函数。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"原型链\">原型链</h3>\n<ul>\n<li>原型链可以简单理解为原型组成的链，对象的_proto_就是其原型，而原型也是一个对象，也有_proto_属性。原型的_proto_又是原型的原型，这样可以一直向上找，直到找到Object的原型，就是这条原型链的顶端。</li>\n</ul>\n<h3 id=\"借用构造函数，也称伪造对象或经典继承\">借用构造函数，也称伪造对象或经典继承</h3>\n<ul>\n<li>\n<p>借用构造函数实现继承的基本思想是：在子类的构造函数中调用超类的构造函数。该函数可以通过apply()方法和call()方法在新创建的对象中执行构造函数。</p>\n<blockquote>\n<ul>\n<li>优点：相对于原型链而言，借用构造函数可以在子类构造函数中向超类构造函数传递数据。</li>\n<li>缺点：构造函数的方法都在构造函数中定义，因此无法实现函数复用。另外，子类无法看见在超类中定义的方法，导致所有类型只能使用构造函数模式。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"组合继承\">组合继承</h3>\n<ul>\n<li>组合继承，又称为伪经典继承。指：将原型链和借用构造函数的技术组合在一起，从而发挥两者长处的一种继承模式。\n<blockquote>\n<p>其思想是：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。这样，我们就可以实现通过在原型上定义方法进而实现函数复用，又能保证每个实例都有自己的属性，解决原型链中存在的引用类型属性共享问题。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"原型式继承\">原型式继承</h3>\n<ul>\n<li>原型式继承，即：一个构造方法，通过原型链的方式继承另一个构造函数。</li>\n</ul>\n<h3 id=\"寄生式继承\">寄生式继承</h3>\n<ul>\n<li>寄生式继承，即：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回该对象。</li>\n</ul>\n<h3 id=\"寄生组合式继承\">寄生组合式继承</h3>\n<ul>\n<li>寄生组合式继承是JS最常用的继承模式，其最大的问题就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类原型时，另一次是在子类构造函数内部。</li>\n</ul>\n<h2 id=\"函数操作\">函数操作</h2>\n<h3 id=\"函数表达式\">函数表达式</h3>\n<blockquote>\n<p>使用函数表达式创建的函数，必须先赋值再调用。（即：只有函数声明式才有函数提升，函数表达式没有函数提升。）</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn2(); <span class=\"comment\">// 不能在函数之前调用。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;2.演示函数表达式&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn2(); <span class=\"comment\">// 只能在函数之前调用。</span></span><br></pre></td></tr></table></figure>\n<p><strong>虽然函数表达式没有函数提升，但是它也有自己的一些优点。</strong></p>\n<h2 id=\"递归函数\">递归函数</h2>\n<ul>\n<li>\n<p>递归函数，就是在函数体内调用本函数。最简单的例子就是计算阶乘： 1<em>2</em>3…。</p>\n</li>\n<li>\n<p>递归的缺点：如果递归函数的终止条件不明确甚至缺失，会导致该函数长时间运行，使用户界面处于假死状态。另外，当递归使用太多甚至超过最大调用栈内存容量时，浏览器会报错。</p>\n</li>\n</ul>\n<h3 id=\"闭包\">闭包</h3>\n<ul>\n<li>闭包，是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另一个函数。</li>\n<li>JS中，一般为了给某个函数声明一些只有该函数才能使用的局部变量时就会使用闭包，这样可以减少全局作用域中的变量，净化全局作用域。但是闭包会占用更多的内存。</li>\n</ul>\n<h2 id=\"模仿块级作用域\">模仿块级作用域</h2>\n<ul>\n<li><strong>JS中没有块级作用域，我们可以进行模仿块级作用域。</strong></li>\n</ul>\n<blockquote>\n<p>使用方式：<br>\n简单来讲，就是定义并立即调用一个匿名函数。<br>\n具体步骤，就是将匿名函数声明（函数表达式）在一对圆括号中，而紧随其后的一对圆括号会立即调用该函数。</p>\n</blockquote>\n<h3 id=\"私有变量\">私有变量</h3>\n<ul>\n<li>严格来讲，JS中没有私有成员的概念，所有对象属性都是公开的。</li>\n<li>但是，任何在函数中定义的变量都可以认为是私有变量，因为不能在函数外部访问。</li>\n<li>私有变量包括函数参数，局部变量以及在函数内部定义的其他函数。</li>\n<li>闭包函数可以持有这些私有变量，并在外部访问。</li>\n</ul>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/fec01c07.html",
            "url": "https://miraitowa.cc/post/fec01c07.html",
            "title": "JavaScript高级②-面向对象的程序设计",
            "date_published": "2021-03-19T10:00:00.000Z",
            "content_html": "<p><strong><code>JavaScript是基于对象编程的</code>，<code>面向对象是一种编程思想</code>。</strong></p>\n<h2 id=\"类和对象\">类和对象</h2>\n<ol>\n<li>类：我们善于将事物进行分类，类是一个抽象的概念。</li>\n<li>对象：具体的事物。\n<ul>\n<li>猫是一类</li>\n<li>楼下的大黄  —&gt;  对象</li>\n</ul>\n</li>\n<li>类是对象的抽象，对象是类的具体事例。</li>\n<li>类不占用内存，对象占用内存空间。</li>\n</ol>\n<h2 id=\"Object类型\">Object类型</h2>\n<ul>\n<li>Object对象，是所有JavaScript对象的超类（基类）。</li>\n<li>Object.prototype（Object的原型）定义了JS对象的基本方法和属性。</li>\n</ul>\n<h3 id=\"声明对象-Object变量定义-两种方法\">声明对象(Object变量定义) 两种方法</h3>\n<ul>\n<li>字面量声明 var obj = {};</li>\n<li>new运算符 var obj = new Object();</li>\n</ul>\n<h3 id=\"对象类型的判断\">对象类型的判断</h3>\n<ul>\n<li><code>console.log(typeof  obj);</code></li>\n</ul>\n<h3 id=\"添加对象属性的方法\">添加对象属性的方法</h3>\n<ol>\n<li>语法 ：<a href=\"http://obj.id\">obj.id</a> = “abc”;</li>\n<li>[ ]方括号语法：  obj[“id”]= “abc”;</li>\n</ol>\n<h3 id=\"删除对象属性的方法\">删除对象属性的方法</h3>\n<ul>\n<li>delete <a href=\"http://obj.id\">obj.id</a>;</li>\n<li>delete obj[“id”];</li>\n</ul>\n<h3 id=\"遍历对象\">遍历对象</h3>\n<ul>\n<li>for in 循环</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">&quot;zhangsan&quot;</span>,</span><br><span class=\"line\">  age:<span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key,obj[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//name zhangsan</span></span><br><span class=\"line\"><span class=\"comment\">//age 20</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"检测对象有没有某个属性\">检测对象有没有某个属性</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&quot;name&quot;</span> <span class=\"keyword\">in</span> obj)         （判断有）</span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj.name === <span class=\"literal\">undefined</span>)（判断没有）</span><br></pre></td></tr></table></figure>\n<h2 id=\"Function类型\">Function类型</h2>\n<blockquote>\n<p>Function类型是JS中的引用类型之一，每个函数实际上都是Function类型的实例对象，具有自己的属性和方法。正因为函数式对象，所以函数名实际上也是一个指向函数对象的指针。</p>\n</blockquote>\n<h3 id=\"函数的定义方式\">函数的定义方式</h3>\n<ol>\n<li>使用function关键字定义函数：（函数声明式）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过变量声明（表达式）定义函数：（函数表达式）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数的调用\">函数的调用</h3>\n<ol>\n<li>通过函数名调用： <code>sum()</code>;</li>\n<li>事件绑定调用：   <code>obj.onclick = sum</code>;<br>\n<strong>注意：函数名仅仅保存指向函数对象的指针，隐藏函数名与包含对象指针的其他变量一样。也就是说，一个函数对象可以有多个名字。</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如：<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( sum(<span class=\"number\">5</span>,<span class=\"number\">10</span>) );   <span class=\"comment\">// 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 变量sum2也指向了同一个函数对象   </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum2 = sum;<span class=\"comment\">// sum后面不加括号，不传参数。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( sum2(<span class=\"number\">3</span>,<span class=\"number\">5</span>) );   <span class=\"comment\">// 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">sum = <span class=\"literal\">null</span>;<span class=\"comment\">// sum对象不再保存函数对象的指针了</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( sum2(<span class=\"number\">3</span>,<span class=\"number\">5</span>) );   <span class=\"comment\">// sum2这个变量仍能继续使用</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数的重载\">函数的重载</h2>\n<blockquote>\n<p>所谓重载，就是一组相同的函数名，有不同个数的参数，在使用时调用一个函数名，传入不同参数，根据你的参数个数，来决定使用不同的函数！但是JS中是没有重载的，因为后定义的函数会覆盖前面的同名函数。<br>\n<strong>在JS中，我们实现重载的常用方式有：</strong></p>\n</blockquote>\n<ol>\n<li>根据传入参数的不同类型进行重载；</li>\n<li>利用参数中特殊的参数值进行重载；</li>\n<li>根据参数的个数进行重载（最简单的方式：switch case 用法）</li>\n</ol>\n<h2 id=\"函数声明式，函数表达式与函数提升\">函数声明式，函数表达式与函数提升</h2>\n<ol>\n<li>\n<p>JS中的声明函数的方法有两种：函数声明式和函数表达式。</p>\n<blockquote>\n<p><strong>两者区别如下：</strong></p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>函数声明式必须要有函数名</code>，而函数表达式的<code>函数名</code>是<code>可选</code>的。</li>\n<li>以<code>函数声明式</code>定义的函数<code>可以在其声明之前被调用</code>，而以<code>函数表达式</code>声明的函数<code>只能在其后被调用</code>。</li>\n<li>以<code>函数声明式</code>定义的函数<code>仅仅可以出现在全局中，或者嵌套在其他函数中</code>，<code>不能出现在循环语句</code>，条件语句和try/catch/finally中；而<code>函数表达式可以在任何地方声明</code>。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>函数提升</p>\n<blockquote>\n<p>函数提升，即：自动把函数的作用范围提升到全局中。而<code>只有函数声明式才存在函数提升</code>。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"函数内部属性：arguments-this\">函数内部属性：arguments, this</h2>\n<ol>\n<li><code>arguments</code>：用来存放传输参数的数组，可以被调用多次，每次数组都不一样。</li>\n<li><code>this</code>：<code>谁调用函数，谁就是this</code>。进行方法调用的时候函数前面是有window的，只是通常会省略掉。</li>\n</ol>\n<h2 id=\"函数的属性和方法\">函数的属性和方法</h2>\n<ol>\n<li>\n<p><code>length</code>属性</p>\n<blockquote>\n<p>arguments对象的length属性表示实参个数，函数的length属性则表示形参个数。</p>\n</blockquote>\n</li>\n<li>\n<p><code>name</code>属性：访问到给定函数指定的名字，即：跟在function关键字后的标识符。<code>匿名函数的name属性为空</code>。</p>\n</li>\n<li>\n<p><code>prototype</code>属性：是每个函数都有的属性，该属性指向一个对象的引用，这个对象称作<code>原型对象（prototype object）</code>。每一个函数都包含不同的原型对象。将函数用做构造函数时，新创建的对象会从原型对象中继承属性。</p>\n</li>\n<li>\n<p><code>apply()</code>方法和<code>call()</code>方法：是每个函数都有的方法，等同于函数体内this对象的值。（后面讲解）</p>\n</li>\n</ol>\n<h2 id=\"基本包装类型\">基本包装类型</h2>\n<blockquote>\n<p>为了便于操作基本类型的值，ECMAScript提供了3种特殊的引用类型：<code>Boolean</code>, <code>Number</code>, <code>String</code>。他们与其他引用类型的使用方法相似，同时也具有各自的基本类型的属性。实际上，每当读取一个基本类型的值，后台就会创建一个对应的基本包装类型的对象，从而可以调用对应的方法。</p>\n</blockquote>\n<ol>\n<li><code>Boolean</code>类型：没有特定的属性和方法。</li>\n<li><code>Number</code>类型：有静态属性，可以直接调用里面的属性和方法，<code>无需new出来</code>。</li>\n<li><code>String</code>类型：包含String对象属性，字符串方法，字符串操作方法，字符串位置方法等。</li>\n</ol>\n<h2 id=\"JS内置对象介绍\">JS内置对象介绍</h2>\n<ol>\n<li>String对象：字符串对象</li>\n<li>Array对象：数组对象</li>\n<li>Date对象：日期时间对象</li>\n<li>Boolean对象：布尔对象</li>\n<li>Number对象：数值对象</li>\n<li>Math对象：数学对象</li>\n<li>RegExp对象：正则对象</li>\n</ol>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/4f09663b.html",
            "url": "https://miraitowa.cc/post/4f09663b.html",
            "title": "JavaScript高级①-变量、作用域和内存",
            "date_published": "2021-03-16T10:00:00.000Z",
            "content_html": "<h2 id=\"掌握基本类型和引用类型的值\">掌握基本类型和引用类型的值</h2>\n<ol>\n<li>ECMAScript的数据类型包括两种：基本数据类型和引用数据类型。</li>\n<li>基本数据类型指的是简单的数据段，常见的基本数据类型有： number, string, boolean, null, undefined。</li>\n<li>引用数据类型指的是由多个值构成的对象，常见的引用数据类型（即：对象类型Object type）有： Object, Array, Function, Date等。</li>\n<li>当我们对变量赋值时，解析器首先要确认的就是这个值是基本类型值，还是引用类型值。</li>\n<li>两种数据类型的区别点如下：\n<ul>\n<li>声明变量时不同的内存分配。基本类型的值保存在栈内存中，引用类型的值同时保存在栈内存和堆内存中。</li>\n<li>不同的内存分配机制也带来了不同的访问机制。</li>\n<li>赋值变量时的不同。不能给基本类型的值添加属性。</li>\n<li>参数传递的不同（把实参赋值给形参的过程）。</li>\n</ul>\n</li>\n<li>值的比较：\n<ul>\n<li>基本类型的比较是值的比较；</li>\n<li>引用类型的比较是引用的比较；</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"执行环境及作用域\">执行环境及作用域</h2>\n<ol>\n<li>\n<p>执行环境介绍</p>\n<blockquote>\n<p>执行环境是JavaScript中最重要的一个概念。执行函数定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)和一个作用域链(scope chain)，环境中定义的所有变量和函数都保存在其变量对象中。<code>执行环境分为两种，即：全局执行环境和函数执行环境</code>。</p>\n</blockquote>\n</li>\n<li>\n<p>全局执行环境</p>\n<blockquote>\n<p>全局执行环境是最外围的一个执行环境，其变量对象就是全局活动对象(window activation object)，全局执行环境直到应用程序退出（例如：关闭网页或浏览器）时才会被销毁。</p>\n</blockquote>\n</li>\n<li>\n<p>函数执行环境</p>\n<blockquote>\n<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数环境就会被推入一个环境栈中。当函数执行完之后，栈将该执行环境弹出，把控制权返回给之前的执行环境。函数执行环境的变量对象是该函数的活动对象(activation object)。</p>\n</blockquote>\n</li>\n<li>\n<p>作用域链</p>\n<blockquote>\n<p>对于每一个执行环境，都会创建一个与之关联的作用域链。每个执行环境的作用域链的前端，始终都是该执行环境的变量对象，对于全局执行环境就相当于window对象，对于函数执行环境就相当于该函数的活动对象；对于全局执行环境，已经是根部，没有后续；对于函数执行环境，其作用域链的后续就是该函数对象的[scope]属性里的作用域链。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"垃圾收集\">垃圾收集</h2>\n<blockquote>\n<p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。<br>\n这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。</p>\n</blockquote>\n<ol>\n<li>\n<p>标记清除：</p>\n<ul>\n<li><code>JavaScript中最常用的垃圾收集方式是标记清除</code>。</li>\n<li>垃圾收集器会在运行的时候给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。</li>\n<li>在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</li>\n<li>最后垃圾收集器完成内存清除的工作，销毁那些带标记的值并回收它们所占用的空间。</li>\n</ul>\n</li>\n<li>\n<p>引用计数：</p>\n<ul>\n<li>引用计数是不太常见的垃圾收集策略。</li>\n<li>引用计数的含义是跟踪记录每个值被引用的次数。</li>\n<li>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，如果该值同时赋给另一个变量，则该值引用次数加1。相反，如果包含对这个值引用的变量又取了另一个值，则该值引用次数减1。</li>\n<li>当这个值引用次数变成0时就说明没有办法再访问该值了，可将其占用的内存空间回收。</li>\n<li>当垃圾收集器下次运行时，就会释放那些引用次数为0的值所占用的内存。</li>\n</ul>\n</li>\n</ol>\n<p><strong>另外，垃圾收集处理方式除了以上两种策略，还可以进行<code>垃圾周期处理</code>和<code>解除引用</code>。</strong></p>\n<ul>\n<li>垃圾周期处理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔周期性地执行这一操作。</li>\n<li>解除引用：对于全局变量，当不再使用时，使用null赋值是一个良好的习惯。</li>\n</ul>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/5aafef3c.html",
            "url": "https://miraitowa.cc/post/5aafef3c.html",
            "title": "JavaScript基础④-文档对象模型(BOM)",
            "date_published": "2021-03-15T11:00:00.000Z",
            "content_html": "<h2 id=\"DOM介绍\">DOM介绍</h2>\n<blockquote>\n<p>DOM（document object model ）文档对象模型，定义了表示和修改文档所需的对象、行为和属性，以及这些对象之间的关系。它是一个能让程序和脚本动态访问和更新内容，结构和样式的语言平台。</p>\n</blockquote>\n<h2 id=\"DOM中的常用属性\">DOM中的常用属性</h2>\n<ol>\n<li>title:设置或返回当前页面的标题。</li>\n<li>body:提供对body元素的直接访问。</li>\n<li>cookie:设置或返回与当前文档有关的的所有cookie。</li>\n<li>domain:返回当前文档的域名。</li>\n<li>referrer:返回载入当前文档的URL。</li>\n<li>URL:返回当前文档的URL。</li>\n</ol>\n<h2 id=\"DOM中的常用方法\">DOM中的常用方法</h2>\n<ol>\n<li>scrollLeft: 页面在水平方向上的滚动距离</li>\n<li>scrollTop: 页面在垂直方向上的滚动距离</li>\n<li>clientWidth: 页面可见区域的宽度</li>\n<li>clientHeight: 页面可见区域的高度</li>\n</ol>\n<h2 id=\"DOM中的innerText、innerHTML、style属性\">DOM中的innerText、innerHTML、style属性</h2>\n<ol>\n<li>innerText: 获取或设置指定的页面元素内容</li>\n<li>innerHTML: 获取或设置指定的页面元素内容（含有html标签）</li>\n<li>style: 获取或设置样式</li>\n</ol>\n<h2 id=\"DOM中表单对象的常用方法\">DOM中表单对象的常用方法</h2>\n<ul>\n<li>reset():重置</li>\n<li>submit():提交表单</li>\n</ul>\n<h2 id=\"DOM中表单对象的常用属性\">DOM中表单对象的常用属性</h2>\n<ol>\n<li>action:设置或返回表单的action属性(即：提交的路径)</li>\n<li>enctype:设置或返回表单数据在发送到服务器之前的编码方式</li>\n<li>id:设置或返回表单id</li>\n<li>length:返回表单中的元素个数</li>\n<li>method:设置或返回将数据发送到服务器的http方法</li>\n<li>name:设置或返回表单name名称</li>\n<li>target:设置或返回表单提交结果的frame或window名</li>\n</ol>\n<h2 id=\"DOM中表单对象集合-elements\">DOM中表单对象集合: elements[]</h2>\n<blockquote>\n<p>elements[]:即一个数组，包含所有的表单元素</p>\n</blockquote>\n",
            "tags": [
                "js",
                "js基础"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/648a3caa.html",
            "url": "https://miraitowa.cc/post/648a3caa.html",
            "title": "JavaScript基础③-浏览器对象模型(DOM)",
            "date_published": "2021-03-15T10:00:00.000Z",
            "content_html": "<h2 id=\"BOM概述\">BOM概述</h2>\n<ul>\n<li>BOM（browser object model）浏览器对象模型**</li>\n<li>BOM提供了独立于内容而与浏览器窗口进行交互的对象、载入页面的相关信息，其核心对象是window对象。</li>\n<li>BOM 没有相关标准，每个浏览器都定义了自己的属性，并且，都有其自己对BOM的实现方式。</li>\n<li>W3C虽然没有为BOM统一制定标准,但是其中的窗口对象、导航对象等,因功能趋同,实际上已经成为默认的标准。</li>\n</ul>\n<h2 id=\"BOM对象\">BOM对象</h2>\n<h3 id=\"window对象\">window对象</h3>\n<blockquote>\n<p>window对象（宿主对象）表示一个浏览器窗口（或一个框架），所有浏览器的属性和方法，都被定义在window这个对象之上。 js通过window对象，就可以对浏览器进行操作（读取/修改浏览器属性、操作标签元素、响应用户事件等）。 window对象是全局对象，并且是唯一的，因此在使用中可以省略不写，例如：可以只写 document，而不必写 window.document。同样，可以把window对象的方法当作函数来使用，如只写 alert()，而不必写window.alert()。</p>\n</blockquote>\n<p><strong>window方法</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">window的方法</th>\n<th style=\"text-align:left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">alert()</td>\n<td style=\"text-align:left\">提示框</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">confirm()</td>\n<td style=\"text-align:left\">带有确认 取消 按钮的提示框(返回true或false)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">prompt()</td>\n<td style=\"text-align:left\">带有可输入内容的文本域 的提示框</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">setInterval()</td>\n<td style=\"text-align:left\">间隔定时器，可按照指定的周期（以毫秒计）来调用函数或计算表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">clearInterval()</td>\n<td style=\"text-align:left\">清除间隔定时器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">setTimeout()</td>\n<td style=\"text-align:left\">超时定时器，在指定的毫秒数后调用函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">clearTimeout()</td>\n<td style=\"text-align:left\">清除超时定时器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">open()</td>\n<td style=\"text-align:left\">打开一个新的浏览器窗口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">close()</td>\n<td style=\"text-align:left\">关闭窗口</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"history-历史记录\">history 历史记录</h2>\n<h3 id=\"history的属性\">history的属性</h3>\n<ul>\n<li>length:返回浏览器历史列表中URL的数量</li>\n</ul>\n<h3 id=\"histroy的方法\">histroy的方法</h3>\n<ol>\n<li>window.history.go() 刷新</li>\n<li>window.history.go(1) 前进（跳转）</li>\n<li>window.history.go(-1) 后退（跳转）</li>\n<li>window.history.forward() 前进</li>\n<li>window.history.back() 后退</li>\n</ol>\n<h2 id=\"location-定位\">location 定位</h2>\n<ol>\n<li>\n<p>location的属性</p>\n<ul>\n<li>protocol: 当前的URL协议</li>\n<li>hostname: 当前URL的主机名</li>\n<li>port: 当前URL的端口号</li>\n<li>host: 当前的URL主机名和端口号</li>\n<li>pathname: 当前的URL的路径</li>\n<li>hash:  以#开始的URL的锚（想要达到页面中的固定位置时使用）</li>\n<li>search: 以？开始的URL拼接部分</li>\n<li>href:  当前URL的完整路径</li>\n</ul>\n</li>\n<li>\n<p>location的方法</p>\n<ul>\n<li>assign()  加载新的文档（原始页面可以返回，仍然存在）</li>\n<li>reload() 页面重载</li>\n<li>replace()  用新文档替换当前文档（原始页面不可以返回，不存在)</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"navigator-导航\">navigator 导航</h2>\n<blockquote>\n<ol>\n<li>window.navigator.userAgent 浏览器类型、版本、操作系统类型、浏览器引擎类型等信息<br>\n//返回浏览器的名称</li>\n<li>navigator.appName<br>\n//返回浏览器的平台和版本信息</li>\n<li>navigator.appVersion<br>\n//返回指明浏览器中是否启用 cookie 的布尔值</li>\n<li>navigator.cookieEnabled<br>\n//返回运行浏览器的操作系统平台</li>\n<li>navigator.platform</li>\n</ol>\n</blockquote>\n",
            "tags": [
                "js",
                "js基础"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/49eef7dc.html",
            "url": "https://miraitowa.cc/post/49eef7dc.html",
            "title": "javascript基础②-本地对象",
            "date_published": "2021-03-14T10:24:02.000Z",
            "content_html": "<h2 id=\"Date对象的创建\">Date对象的创建</h2>\n<h3 id=\"获取当前日期及时间\">获取当前日期及时间</h3>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 = <span class=\"keyword\">new</span>  <span class=\"built_in\">Date</span>();</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h3 id=\"设置指定时间\">设置指定时间</h3>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 = <span class=\"keyword\">new</span>  <span class=\"built_in\">Date</span>(年，月，日);</span><br><span class=\"line\"><span class=\"keyword\">var</span> 变量名 = <span class=\"keyword\">new</span>  <span class=\"built_in\">Date</span>(年，月，日，时，分，秒，毫秒);</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"Date对象中的常用方法\">Date对象中的常用方法</h2>\n<ol>\n<li>\n<p>to方法组:(<code>转换</code>)</p>\n<ul>\n<li><code>toString()</code>把日期转换成字符串</li>\n<li><code>toLocaleString()</code>把日期转换成本地时间(年月日时分秒)</li>\n<li><code>toLocaleDateString()</code>把日期转换成本地时间(年月日)</li>\n<li><code>toLocaleTimeString()</code>把日期转换成本地时间(时分秒)</li>\n</ul>\n</li>\n<li>\n<p>get方法组:(<code>获取</code>)</p>\n<ul>\n<li><code>getDate()</code>获取一个月的某一天日期(1-31)</li>\n<li><code>getDay()</code>获取一周中的某一天(0-6)—(星期天是0)</li>\n<li><code>getMonth()</code>获取月份(0-11)</li>\n<li><code>getFullYear()</code>获取四位数字的年份</li>\n<li><code>getHours()</code>获取小时数(0-23)</li>\n<li><code>getMinutes()</code>获取分钟数(0-59)</li>\n<li><code>getSeconds()</code>获取秒数(0-59)</li>\n</ul>\n</li>\n<li>\n<p>set方法组:(<code>设置</code>)</p>\n<ul>\n<li><code>setDate()</code>设置一个月的某一天日期(1-31)</li>\n<li><code>setMonth()</code>设置月份(0-11)</li>\n<li><code>setFullYear()</code>设置四位数字的年份</li>\n<li><code>setHours()</code>设置小时数(0-23)</li>\n<li><code>setDay</code>(这个真<code>没有!!!!</code>,<code>星期是通过设定日期自动计算的</code>)</li>\n<li><code>setFullYear(year，month，day)</code>\n<blockquote>\n<ul>\n<li><code>year</code>:<code>必需</code>表示年份的四位整数。</li>\n<li><code>month</code>:<code>可选</code>,介于 <code>0 ~ 11</code> 之间。如果不填，取系统当月-1为去年的最后一个月,12为明年的第一个月,13为明年的第二个月。</li>\n<li><code>day</code>:<code>可选</code>，表示月中某一天的数值。如果不填，取系统当日本地时间表示。介于 1 ~ 31 之间,0 为上个月最后一天,-1 为上个月最后一天之前的天数,如果当月有31天: 32 为下个月的第一天,如果当月有30天: 32 为下一个月的第二天。</li>\n</ul>\n</blockquote>\n</li>\n<li><code>setHours</code>(<code>hour</code>,<code>min</code>,<code>sec</code>,<code>millisec</code>)\n<blockquote>\n<ul>\n<li>可以有4个参数</li>\n<li>hour:小时</li>\n<li>min:分钟</li>\n<li>sec:秒</li>\n<li>millisec:毫秒</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"字符串的常用方法\">字符串的常用方法</h2>\n<ol>\n<li>\n<p><code>length</code>: 获取字符串的长度</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;中华人民共和国&quot;</span>;</span><br><span class=\"line\">alert( str.length);\t<span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>slice(start[,end])</code>截取字符串，<code>start</code>–开始索引 <code>end</code>–结束索引<br>\n<strong>返回:包含开始位置，不包含结束位置(含头不含尾)</strong></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;中华人民共和国&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str1 = str.slice(<span class=\"number\">2</span>,<span class=\"number\">4</span>);<span class=\"comment\">//人民</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>substring(start [,end])</code>截取字符串，<code>start</code>:开始的索引位置,<code>end</code>: 结束的索引位置(不写到末尾)</p>\n<p><strong>返回:包含开始位置，不包含结束位置(含头不含尾)</strong></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;中华人民共和国&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str1 = str.substr(<span class=\"number\">2</span>,<span class=\"number\">4</span>);\t<span class=\"comment\">//人民</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>substr(start[,length])</code>，<code>start</code>:开始的索引位置,取<code>length</code>个字符(不写到末尾)</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;中华人民共和国&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str1 = str.substr(<span class=\"number\">2</span>,<span class=\"number\">5</span>);\t<span class=\"comment\">//人民共和国</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>split()</code>，按条件分割字符串，返回一个字符串数组</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;中华人民共和国&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">&quot;&quot;</span>);\t <span class=\"comment\">//[&quot;中&quot;, &quot;华&quot;, &quot;人&quot;, &quot;民&quot;, &quot;共&quot;, &quot;和&quot;,&quot;国&quot;]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">&quot;杏|石|口|路|81|号&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = str1.split(<span class=\"string\">&quot;|&quot;</span>);\t <span class=\"comment\">//[&quot;杏&quot;, &quot;石&quot;, &quot;口&quot;, &quot;路&quot;, &quot;81&quot;, &quot;号&quot;]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>indexOf()</code>:在父串中首次出现的位置索引，从0开始！没有就返回-1</p>\n</li>\n<li>\n<p><code>lastIndexOf()</code>:倒序查找</p>\n</li>\n<li>\n<p><code>charAt(index)</code>:获取指定索引的字符</p>\n</li>\n<li>\n<p><code>toLowerCase()</code>:转小写</p>\n</li>\n<li>\n<p><code>toUpperCase()</code>:转大写</p>\n</li>\n</ol>\n<h2 id=\"数组\">数组</h2>\n<blockquote>\n<p>Array (数组)对象用于在单个的变量中存储多个值。数组可存放任意数据类型，并通过索引来访问每个元素。</p>\n</blockquote>\n<h3 id=\"数组的声明\">数组的声明</h3>\n<ol>\n<li>\n<p>先声明再赋值:</p>\n<ul>\n<li>声明方式1:var arr = new Array();  // 可根据需要在( )中指定长度</li>\n<li>声明方式2:var arr = [];</li>\n</ul>\n<blockquote>\n<p>赋值:数组名[索引] = 值;   // arr[0] = 10;</p>\n</blockquote>\n</li>\n<li>\n<p>直接声明并赋值</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(“值<span class=\"number\">1</span>”,,,,,,“值N”);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"数组的长度-数组名-length\">数组的长度:<code>数组名.length</code></h3>\n<h3 id=\"数组的遍历方式\">数组的遍历方式</h3>\n<ol>\n<li>\n<p>循环遍历</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(arr[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>直接输出数组名</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.write(arr);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"数组的常用方法\">数组的常用方法:</h3>\n<ol>\n<li>\n<p><code>join()</code>: 用指定的元素对数组进行分割。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>];</span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(arr.join(“*”));  <span class=\"comment\">// 10*20*30</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>indexOf</code>:搜索一个指定的元素的位置，如未找到返回 -1；</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"string\">&quot;30&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">10</span>)); <span class=\"comment\">//元素10的索引为0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">30</span>)); <span class=\"comment\">//元素30未找到，返回-1</span></span><br><span class=\"line\"><span class=\"comment\">//注意:数字30和字符串&quot;30&quot;是不同元素</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>concat()</code>:把当前的数组 和 另一个数组连接起来，并返回一个新的 数组；</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> newArr = arr1.concat(arr2,<span class=\"string\">&quot;再次添加&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArr); <span class=\"comment\">//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,1,2,3,&quot;再次添加&quot;];</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1); <span class=\"comment\">//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>push()</code>:向数组的末尾添加若干元素</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop(): 把数组的最后一个元素删除掉</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">arr.push(<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);<span class=\"comment\">//[1,2,&quot;a&quot;,&quot;b&quot;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.pop(); <span class=\"comment\">//返回“b”;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[1,2,&quot;a&quot;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.pop();</span><br><span class=\"line\">arr.pop();</span><br><span class=\"line\">arr.pop();  <span class=\"comment\">//连续3次pop，空数组继续pop不会报错</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//打印[]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>unshift()</code>: 向数组前面添加若干元素</p>\n</li>\n<li>\n<p><code>shift()</code>: 则把数组的第一个元素删除掉</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">arr.unshift(<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">//返回新长度 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);<span class=\"comment\">//打印[&quot;a&quot;,&quot;b&quot;,1,2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//返回&quot;a&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//打印[&quot;b&quot;,1,2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.shift();arr.shift();arr.shift(); <span class=\"comment\">//连续3次</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//打印[]</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.shift(); <span class=\"comment\">//空数组继续删除不报错，返回undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//打印[]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>slice()</code>: 截取数组的部分元素，然后返回一个新的数组</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>,<span class=\"string\">&quot;d&quot;</span>,<span class=\"string\">&quot;e&quot;</span>,<span class=\"string\">&quot;f&quot;</span>,<span class=\"string\">&quot;g&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>)); <span class=\"comment\">//从索引0开始，到索引3结束，但不包括3:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.slice(<span class=\"number\">3</span>));  <span class=\"comment\">//从索引3开始到结束:&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;</span></span><br><span class=\"line\">如果不给slice()传递任何参数，他就会从头到尾截取所有元素。利用这一点，可以很容易的复制一份新的数组</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> aCopy = arr.slice();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(aCopy); <span class=\"comment\">//[1,2,3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>sort()</code>: 可以对当前数组排序</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>,<span class=\"string\">&quot;a&quot;</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);<span class=\"comment\">//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>reverse()</code>: 把整个数组的元素给掉个个，也就是反转</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;one&quot;</span>,<span class=\"string\">&quot;two&quot;</span>,<span class=\"string\">&quot;three&quot;</span>];</span><br><span class=\"line\">arr.reverse();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[&quot;three&quot;,&quot;two&quot;,&quot;one&quot;]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>join()</code>: 把数组的每个元素用指定的字符串连接起来，然后新的字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">arr.join(<span class=\"string\">&quot;-&quot;</span>); <span class=\"comment\">//&quot;a-b-c-1-2-3&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>splice()</code>: 是修改数组的“万能方法”，他可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//splice(索引值，删除数量，&quot;值1&quot;，&quot;值2&quot;);</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;苹果&quot;</span>,<span class=\"string\">&quot;橘子&quot;</span>,<span class=\"string\">&quot;香蕉&quot;</span>,<span class=\"string\">&quot;芋头&quot;</span>,<span class=\"string\">&quot;桂圆&quot;</span>,<span class=\"string\">&quot;山楂&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从索引2开始删除3个元素，然后再添加两个元素</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">&quot;白梨&quot;</span>,<span class=\"string\">&quot;西瓜&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// &quot;苹果&quot;,&quot;橘子&quot;,&quot;白梨&quot;,&quot;西瓜&quot;,&quot;山楂&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//只删除，不添加</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">2</span>);  <span class=\"comment\">//&quot;白梨&quot;,&quot;西瓜&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//&quot;苹果&quot;,&quot;橘子&quot;,&quot;山楂&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//只添加，不删除</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"string\">&quot;白梨&quot;</span>,<span class=\"string\">&quot;西瓜&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);<span class=\"comment\">// &quot;苹果&quot;,&quot;橘子&quot;,&quot;白梨&quot;,&quot;西瓜&quot;,&quot;山楂&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Math的常用方法\">Math的常用方法</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abs()</td>\n<td>绝对值 （去除正负）</td>\n</tr>\n<tr>\n<td>random()</td>\n<td>随机数，0-1之间的随机数，1不会出现</td>\n</tr>\n<tr>\n<td>round()</td>\n<td>四舍五入</td>\n</tr>\n<tr>\n<td>floor(x)</td>\n<td>下舍入(向下取整)–地板</td>\n</tr>\n<tr>\n<td>ceil(x)</td>\n<td>上舍入(向上取整)–天花板</td>\n</tr>\n<tr>\n<td>max(x,y)</td>\n<td>x 和 y 中的最大值</td>\n</tr>\n<tr>\n<td>min(x,y)</td>\n<td>x 和 y 中的最小值</td>\n</tr>\n<tr>\n<td>cos(x)</td>\n<td>的余弦</td>\n</tr>\n<tr>\n<td>sin(x)</td>\n<td>x的正弦</td>\n</tr>\n<tr>\n<td>sqrt(x)</td>\n<td>返回x的平方根</td>\n</tr>\n<tr>\n<td>pow(3,4)</td>\n<td>返回3的4次方</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Math函数的属性：<code>PI</code>  圆周率。使用方法：<code>Math.PI</code></strong></p>\n<h2 id=\"全局对象中的常用方法（强制转换）\">全局对象中的常用方法（强制转换）</h2>\n<ol>\n<li><code>isNaN()</code>:判断是否是数字，不是数字返回true，是数字返回false;(<code>isNaN:is not a number</code>)</li>\n<li><code>eval()</code>把字符串里面的数字进行计算</li>\n<li><code>parseFloat()</code>把字符串转换为小数</li>\n<li><code>parseInt()</code>把字符串转换为整数</li>\n</ol>\n<h2 id=\"函数的定义、调用\">函数的定义、调用</h2>\n<ol>\n<li>函数的概念</li>\n</ol>\n<blockquote>\n<p>函数是ECMAScript的核心，包含一些代码，只有被调用以后才会执行。函数是对象数据类型的一种。</p>\n</blockquote>\n<ol start=\"2\">\n<li>\n<p>定义函数的语法：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> 函数名(<span class=\"params\">参数</span>)</span>&#123;</span><br><span class=\"line\">函数体(也称为：方法体);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数的调用</p>\n<blockquote>\n<p>函数名(参数值);</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"正则表达式\">正则表达式</h2>\n<ol>\n<li>\n<p>正则表达式的概念</p>\n<blockquote>\n<p><code>RegExp</code>（正则表达式）是一个对象，就是用一个“字符串”来描述一个特征，然后去校验另一个“字符串”是否符合该特征。主要实现对<code>字符串的匹配</code>、<code>分割</code>、<code>查找</code>、<code>替换</code>、<code>校验</code>等操作。</p>\n</blockquote>\n</li>\n<li>\n<p>元字符<br>\n<strong>正则模式当中的元字符，通常都具有特殊的含义</strong></p>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a-z</td>\n<td>英文小写字母</td>\n</tr>\n<tr>\n<td>A-Z</td>\n<td>英文大写字母</td>\n</tr>\n<tr>\n<td>0-9</td>\n<td>数字</td>\n</tr>\n<tr>\n<td>\\r  \\n \\t</td>\n<td>非打印字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>数字，相当于0-9</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>\\d  取反</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>字母 数字 下划线</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>\\w  取反</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>空白字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>非空白字符</td>\n</tr>\n<tr>\n<td>[  ]</td>\n<td>任意匹配[ ]中单个字符</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配任意字符（换行符除外）</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>匹配n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>匹配至少n次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>至少n次，最多m次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配0个或多个，相当于{0,}</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配1个或多个，相当于{1,}</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配0个或1个，相当于{0,1}</td>\n</tr>\n<tr>\n<td>^</td>\n<td>1、匹配正则开头  2、放在[^]，内容取反</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配正则结尾</td>\n</tr>\n<tr>\n<td>|</td>\n<td>匹配 | 两侧任选其一</td>\n</tr>\n<tr>\n<td>(  )</td>\n<td>1.  分组 2.子存储</td>\n</tr>\n</tbody>\n</table>\n<p>**注意：**正则需要转义字符： ( ) { } ? * + . [ ] \\ / ^ $ |</p>\n</li>\n<li>\n<p>正则的定义：</p>\n<ol>\n<li>方式1：var re = /正则内容/;</li>\n<li>方式2：var re = new RegExp(正则内容);</li>\n</ol>\n</li>\n<li>\n<p>test方法：检索字符串中指定的值。返回 true 或 false。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span>  txt=<span class=\"string\">&quot;this a cat, that a dog&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span>  re=<span class=\"regexp\">/cat/</span>;</span><br><span class=\"line\">alert(re.test(txt));   <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n",
            "tags": [
                "js",
                "JavaScript基础"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/1caa3095.html",
            "url": "https://miraitowa.cc/post/1caa3095.html",
            "title": "JavaScript基础①-概述及语法基础",
            "date_published": "2021-03-13T10:00:00.000Z",
            "content_html": "<h2 id=\"JavaScript的组成\">JavaScript的组成:</h2>\n<ol>\n<li>核心(ECMAScript):由Ecma国际(前身为欧洲计算机制造商协会，European Computer Manufacturers Association)通过ECMA-262标准化的脚本程序设计语言。</li>\n<li>文档对象模型(Document Object Model，简称DOM):是W3C组织推荐的处理可扩展置标语言的标准编程接口。描述了访问网页元素的方法和接口。</li>\n<li>浏览器对象模型(Browser Object Model，简称BOM):描述了与浏览器进行交互的方法和接口。\n<ul>\n<li>基本语法:\n<ol>\n<li><code>注意行尾加分号;</code></li>\n<li><code>换行书写;</code></li>\n<li><code>单行注释:// 或者 多行注释/**/</code></li>\n</ol>\n</li>\n<li>补充:页面输出语句;<br>\n<code>alert(&quot;Hello Word&quot;); //系统弹窗</code><br>\n<code>console.log(); //输出在控制台</code><br>\n<code>document.write(); //打印在页面</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JavaScript的常用运算符\">JavaScript的常用运算符:</h2>\n<ol>\n<li>\n<p>算术运算符:<code>+</code>  <code>-</code>  <code>*</code>  <code>/</code>  <code>%</code>  <code>++</code>  <code>--</code><br>\n<strong>🐔  i++ 与 ++i 的区别:</strong></p>\n<ol>\n<li>如果单独在一行，都自增1；</li>\n<li>当与其他运算符或者输出语句一起使用时:\n<ul>\n<li>i++:先赋值使用，再运算；(<code>++在后，先用后加</code>)</li>\n<li>++i:先运算，再赋值使用；(<code>++在前，先加后用</code>)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>比较运算符:<code>&gt;</code>  <code>&gt;=</code>  <code>&lt;</code>  <code>&lt;=</code>  <code>==</code>  <code>!=</code> ,返回结果:<code>真或假(true/false)</code></p>\n</li>\n<li>\n<p>逻辑运算符:<code>&amp;&amp;</code>  <code>||</code>  <code>!</code> (<code>与</code>、<code>或</code>、<code>非</code>)</p>\n<ul>\n<li>&amp;&amp;:<code>两边为真，才为真</code>。<code>其中一个为假，即为假</code>。</li>\n<li>||:<code>其中一个为真，即为真</code>。</li>\n<li>！:<code>真假互换</code>。</li>\n</ul>\n</li>\n<li>\n<p>条件运算符:(表达式1  ?  表达式2  : 表达式3)</p>\n<ul>\n<li>判断“表达式1”的结果是否为真，</li>\n<li>如果为真则执行“表达式2”，否则执行“表达式3”。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"条件分支语句-if，switch\">条件分支语句:if，switch</h2>\n<ul>\n<li><strong>if语句:</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法:</span><br><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">语句块;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>if…else语句:</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法:</span><br><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">语句块<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">语句块<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>多分支if语句(if…else if 语句):</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法:</span><br><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">语句块<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(条件表达式<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">语句块<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">语句块N;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>switch语句:</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(表达式)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> 值<span class=\"number\">1</span>:</span><br><span class=\"line\">语句块<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"keyword\">case</span> 值N:</span><br><span class=\"line\">语句块N;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">语句块;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环语句\">循环语句:</h2>\n<ul>\n<li>while</li>\n<li>do…while</li>\n<li>for</li>\n<li>for in</li>\n<li>break和continue的使用</li>\n</ul>\n<hr />\n<ul>\n<li>while循环:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(条件表达式)&#123;</span><br><span class=\"line\">循环语句;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>执行流程:判断条件表达式是否为真，如果为真，就执行后面的循环语句。然后再次判断，直到条件为假时，跳出while循环。</p>\n</blockquote>\n<hr />\n<ul>\n<li>do…while循环:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">循环语句;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(条件表达式);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>执行流程:先执行语句，再判断条件，如果为真就继续执行循环语句。否则跳出循环。</p>\n</blockquote>\n<blockquote>\n<p>while与do-while的区别:<br>\nwhile先判断再执行，<br>\ndo-while先执行后判断(至少执行一次)。</p>\n</blockquote>\n<hr />\n<ul>\n<li>for循环:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(初始表达式<span class=\"number\">1</span>; 条件表达式<span class=\"number\">2</span>; 迭代表达式<span class=\"number\">3</span> )&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">循环语句<span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>for in (对象篇详解)</p>\n</li>\n<li>\n<p>break:跳出循环<br>\ncontinue: 跳过该次循环，执行后面的循环\t\t\t(例:test07)</p>\n</li>\n</ul>\n<hr />\n<h2 id=\"关键词与变量命名\">关键词与变量命名</h2>\n<ul>\n<li>ECMAScript 关键字的完整列表:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><strong>break</strong></td>\n<td style=\"text-align:center\"><strong>else</strong></td>\n<td style=\"text-align:center\"><strong>new</strong></td>\n<td style=\"text-align:center\"><strong>var</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>case</strong></td>\n<td style=\"text-align:center\"><strong>finally</strong></td>\n<td style=\"text-align:center\"><strong>return</strong></td>\n<td style=\"text-align:center\"><strong>void</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>catch</strong></td>\n<td style=\"text-align:center\"><strong>for</strong></td>\n<td style=\"text-align:center\"><strong>switch</strong></td>\n<td style=\"text-align:center\"><strong>while</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>continue</strong></td>\n<td style=\"text-align:center\"><strong>function</strong></td>\n<td style=\"text-align:center\"><strong>this</strong></td>\n<td style=\"text-align:center\"><strong>with</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>default</strong></td>\n<td style=\"text-align:center\"><strong>if</strong></td>\n<td style=\"text-align:center\"><strong>throw</strong></td>\n<td style=\"text-align:center\"><strong>let</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>delete</strong></td>\n<td style=\"text-align:center\"><strong>in</strong></td>\n<td style=\"text-align:center\"><strong>try</strong></td>\n<td style=\"text-align:center\"><strong>do</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><strong>instanceof</strong></td>\n<td style=\"text-align:center\"><strong>typeof</strong></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>定义变量<br>\n变量variable(临时存储的容器)<br>\n//变量:临时存储信息的容器，可以复用</p>\n<blockquote>\n<ul>\n<li>\n<p>var name; //变量的声明，并起名叫 name</p>\n</li>\n<li>\n<p>name = “tt”; //为变量赋值,<code>=</code> 等号:是把右侧的值，<code>赋值</code>给左侧的变量名；</p>\n</li>\n<li>\n<p>变量名大小写敏感</p>\n<ul>\n<li>var Name=“小花”;</li>\n<li>var name=“小毛”;</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>命名规范:</p>\n<blockquote>\n<ol>\n<li>\n<p>必须以字母、数字、下划线或$组成。</p>\n</li>\n<li>\n<p>开头不能是数字。</p>\n</li>\n<li>\n<p>不能是JavaScript的关键字。</p>\n<p><strong>注意:由于JavaScript是弱类型语言，所以在定义变量时，可以省略var，但是不建议使用。</strong></p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JavaScript中的两种数据类型\">JavaScript中的两种数据类型</h2>\n<h3 id=\"原始类型-查看数据类型，使用-typeof\">原始类型:(查看数据类型，使用:  typeof )</h3>\n<ol>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>undefined:变量只定义不赋值，就是undefined</li>\n<li>null:表示一个空对象，“什么都没有”的意思，用来表示无值，就像一个占位符</li>\n</ol>\n<h3 id=\"对象类型-object\">对象类型(object)</h3>\n<p><strong>对象的定义为:“无序属性的集合，其属性可以包含基本值、对象、或者函数”。</strong></p>\n<ul>\n<li>\n<p>js中内置了如下的对象:</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Object</td>\n<td>是所有JS对象的超类(基类)，JS中的所有对象都是继承自Object对象</td>\n</tr>\n<tr>\n<td>Array</td>\n<td>数组对象–定义数组属性和方法</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数字对象</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔对象–布尔值相关</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>错误对象–处理程序错误</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数对象–定义函数属性和方法</td>\n</tr>\n<tr>\n<td>Math</td>\n<td>数学对象</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>日期对象</td>\n</tr>\n<tr>\n<td>RegExp</td>\n<td>对象正则表达式对象–定义文本匹配与筛选规则</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串对象–定义字符串属性和方法</td>\n</tr>\n</tbody>\n</table>\n<p>​</p>\n<p>​</p>\n<p>​</p>\n</li>\n</ul>\n",
            "tags": [
                "js",
                "js基础"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/1158b6cc.html",
            "url": "https://miraitowa.cc/post/1158b6cc.html",
            "title": "移动设备(手机)网站界面设计",
            "date_published": "2021-03-04T04:59:28.000Z",
            "content_html": "<h2 id=\"手机网站的概念及趋势\">手机网站的概念及趋势</h2>\n<ul>\n<li>定义：手机网站是指特地用于手机阅读的网站。这种网站经过以文字信息和简单的图片信息为主。随着向手机智能化方向开展，装置了操作系统和阅读器的手机的功用和电脑是很类似的，但假如仅仅运用手机阅读器看PC网站的话，那还是很费劲的。运用这种手机能够经过GPRS上网可阅读几乎一切的www网站。由于手机的屏幕尺寸和CPU处置才能有限，特地为方便手机浏览而进行优化的网站更为便于用户阅读。目前使用手机上网的用户超过台式电脑用户，手机成为我国网民的第一大上网终端。</li>\n</ul>\n<h2 id=\"前端开发中PC端和移动端网站的区别\">前端开发中PC端和移动端网站的区别</h2>\n<ol>\n<li>PC端在开发过程中考虑的是浏览器兼容性，移动端开发中考虑的是手机兼容性问题，做移动端开发，更多考虑的是手机分辨率的自适应和不同手机操作系统的略微差异化；</li>\n<li>在部分事件的处理上，移动端自然是偏向于触屏的，另外包括移动端弹出的手机键盘该如何处理，这样的问题在PC上肯定不会遇到，但在移动端，如果你没有经验，处理起来是相当麻烦的；</li>\n<li>布局上，移动端开发是要做到页面布局自适应的，而PC端页面布局的比例会相对固定；</li>\n<li>在动画效果处理上，PC端要考虑IE的兼容性，通常用JS做动画的通用性会好一些，但相比CSS3却牺牲了较大的性能，而在手机端，如果要做一些动画、特效等，第一选择肯定是CSS3，既简单，效率又高。</li>\n</ol>\n<h2 id=\"设计手机网站的注意事项：\">设计手机网站的注意事项：</h2>\n<ol>\n<li>明确需要展示的主题和内容；</li>\n<li>尽量符合滑动屏幕的方式；</li>\n<li>特别注意与PC端网站导航功能的区别；</li>\n<li>考虑多种手机界面和浏览器的兼容；</li>\n<li>尽量减少用户文字输入操作；</li>\n<li>开始设计时就要为以后的推广和宣传做预估；</li>\n<li>兼顾非触摸屏幕的设计；</li>\n<li>简化页面内容；</li>\n<li>注重网页产品和服务的展示；</li>\n</ol>\n<h2 id=\"手机网站的布局-使用媒体查询-原始方式\">手机网站的布局:(使用媒体查询(原始方式))</h2>\n<ul>\n<li>@media 在设计响应式页面时是非常有用的。可以针对不同的屏幕尺寸设置不同的样式。使用该方式设计的页面，可以根据浏览器的大小实时地进行高度和宽度的渲染。</li>\n<li>基本格式如下：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span>  mediatype  <span class=\"keyword\">and</span>|<span class=\"keyword\">not</span>|<span class=\"keyword\">only</span>  (mediad feature)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">// CSS代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>碎碎念：这个东西好麻烦的感觉~</p>\n",
            "tags": [
                "前端设计",
                "移动端网站设计"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/5ff78d08.html",
            "url": "https://miraitowa.cc/post/5ff78d08.html",
            "title": "互联网单页设计与推广",
            "date_published": "2021-03-03T04:59:28.000Z",
            "content_html": "<h2 id=\"竞价单页\">竞价单页</h2>\n<p><strong>概念：竞价单页通常都是由一个或几个HTML页面组成，由于HTML对搜索引擎的友好性，通过用来百度、google、搜狗等竞价排名来推广产品，由于大多数的竞价页面都是由一个页面组成，因此取名“竞价单页”。</strong></p>\n<p>竞价产品以其高额的回报率成为近年来“网赚”的新宠，越来越多的“网客”加入竞价的行业，竞价产品的诞生不仅带动了多种行业的发展，更是营销方式的革新，更加促进了电子商务的发展。</p>\n<ol>\n<li>原理功效：主要介绍竞价产品<code>用途</code>、<code>功效</code>、<code>产地</code>，比如减肥的主要说该减肥产品的主要原材料，减肥效果等。</li>\n<li>媒体报道：竞价产品一般都<code>主要靠媒体推广</code>等来营销的，引用主要媒体的视频、文章等来达到推广营销的目的，比如央视网、搜狐、新浪、网易、腾讯等主要媒体。</li>\n<li>用户体验：以<code>图文并茂</code>的形式列举用户使用后的体验和感受，达到增强产品说服力的效果。</li>\n<li>在线问答：<code>主要采取一问一答的方式</code>，网站客服在线回答用户的提问，主要包括产品功效、使用方法、付款方式、使用后的感受、产品运送方式等。</li>\n<li>在线订单：<code>在线订单系统是竞价网页的核心部分，也是它的“灵魂”</code> ，主要用来在线收集用户的信息包括收货人名、购买产品类型、联系方式、收货地址、付款方式等。通过收集这些信息后以邮件方式或保存到数据库等方式供网站卖家查看、发货，达到营销的目的。</li>\n<li>发货记录：发货记录也是竞价单页网站的主要组成部分，通常以循环滚动的方式不间断滚动展示发货信息，达到展示产品销售火爆的景象。</li>\n</ol>\n<h2 id=\"SEO\">SEO</h2>\n<p><strong>SEO优化英文全称：<code>Search Engine Optimization</code>，中文翻译为：<code>搜索引擎优化</code>，缩写为：<code>SEO</code>。关于SEO优化的简单的定义，就是从自然搜索结果获得网站流量的技术和过程，从而改进网站在搜索引擎中自然排名的一种技术。在搜索引擎里面搜索一个关键词，出现在搜索的结果中排名靠前的，广告除外，其余就是靠着SEO优化进行的。</strong></p>\n<h3 id=\"SEO优化的范围\">SEO优化的范围</h3>\n<ul>\n<li>\n<p>SEO优化业务做的工作有网站结构优化、关键词竞争研究，如关键词选择、竞争程度判断、关键词拓展、关键词分布等、还有外链建设、页面优化，而目标都是为了提高网站的流量，即网站访问量。</p>\n</li>\n<li>\n<p>据调查显示，有88% 的用户会利用搜索引擎服务查找需要的信息，而这之中有大部分的用户都会直接在搜索结果的自然排名的第一页信息中，查找选择所需要的信息，所以，如果网站的排名越靠前，那么被访问的几率也就越高，所能带来的业务也就越多。因此网站需要运用SEO进行网站优化，提高网站的排名。</p>\n</li>\n</ul>\n<h4 id=\"内部优化\">内部优化</h4>\n<ol>\n<li>meta标签优化：如：title, keywords, description等优化。</li>\n<li>内部链接优化：如：相关性链接tag标签，锚文本链接，导航链接，图片链接等。</li>\n<li>网站内容更新（主要是文字及内容的更新）</li>\n</ol>\n<h4 id=\"外部优化\">外部优化</h4>\n<ol>\n<li>外部链接类别：友情链接、博客、论坛、新闻，贴吧、知道、百科等。</li>\n<li>外链运营：每天增加一定数量的外部链接，使关键字排名稳步提升。</li>\n<li>外链选择：与相关度比较高的网站交换友情链接。</li>\n</ol>\n<h3 id=\"SEO优化\">SEO优化</h3>\n<ul>\n<li>\n<p>SEO优化的<code>最终目的就是为了获得搜索流量</code>，因此关键词研究，针对有真实用户在搜索的关键词进行优化、文案写作等十分重要。SEO优化就是针对搜索引擎的搜索规则进行网站的优化。</p>\n</li>\n<li>\n<p>SEO优化一般包括<code>站内优化</code>与<code>站外优化</code>两部分，站内优化是指网站本身的内容：更新的速度与质量、网站结构：标题标签，关键词，锚文本的分布、链接等。站外优化主要指外部链接。同时用户还可以结合一些SEO工具来帮助更好地进行网站的优化工作，例如：排名查询，权重查询，收录查询等。</p>\n</li>\n</ul>\n<h3 id=\"SEO优化的走向\">SEO优化的走向</h3>\n<ul>\n<li>流量最终的流向是网站，所以SEO最终目标是帮助网站完成流量转化，比如访问用户通过网站直接带来业务，提高公司业务、广告点击或品牌建设，提升知名度。</li>\n</ul>\n<h3 id=\"互联网站-网页-的权重排名\">互联网站(网页)的权重排名</h3>\n<h4 id=\"网站权重\">网站权重</h4>\n<ul>\n<li>搜索引擎给网站(网页)赋予一定的权威值，对网站(网页)进行权威的评估评价。</li>\n<li>一个网站的权重值越高，在搜索引擎所占的分量越大，排名就越靠前。提高网站的权重值，不但有利于网站（网页）在搜索引擎的排名更靠前，还能提高整站的流量，增加网站的可信度。权重就是网站在SE0中的重要性和权威性。英文名称：Page Strength。</li>\n</ul>\n<p><strong>需要注意的是：</strong></p>\n<ol>\n<li>权重不等于排名。</li>\n<li>权重对排名有非常大的影响。</li>\n<li>整站权重的提高有利于内页的排名。</li>\n</ol>\n<h4 id=\"权重的影响因素\">权重的影响因素</h4>\n<ol>\n<li>网站架构：（优质的网页通常为扁平式包含：主页、栏目页、内容页等，同时包含tag标签，含留言、评论、文章搜索等功能）</li>\n<li>域名类型：（gov, edu结尾类型的网站自身权重较高，可信度高。其次是com, net, org结尾的网站。注册域名越久权重越高）</li>\n<li>导入链接：（关联信较高的友情链接，博客，论坛等）</li>\n<li>网站内容：（优质的原创内容可以给搜索引擎提供新内容。如果不能原创，也尽量避免原封不动的照搬照抄）</li>\n<li>收录数量</li>\n<li>关键词排名</li>\n<li>更新频率</li>\n<li>开放式目录：（被大型公共网页目录：如DMOZ, YAHOO等收录）</li>\n<li>内容页：是否与主页和网站主题有较为紧密的联系。也会参考：专业性和权威性。</li>\n<li>网站的诚信度</li>\n<li>网站服务器：（稳定的服务器）</li>\n</ol>\n<h2 id=\"单页推广技巧概述\">单页推广技巧概述</h2>\n<h3 id=\"head区的组成\">head区的组成</h3>\n<ol>\n<li>\n<p>标题(title):在搜索引擎中抓取的第一行内容就是title，地址栏上方的网页名称中显示的也是title，title就相当于一个人的名字，其重要性不言而喻。<br>\ntitle书写的注意事项：简洁精炼（10个字内为佳），包含网页核心关键词，且尽量靠前。如：“二手车行业领导者”和“领导买卖二手车行业”在搜索结果中的效果是不一样的。</p>\n</li>\n<li>\n<p>meta 属性中的关键词(keywords)<br>\n关键字必须在内容中找到响应的匹配，才有利于排名。<br>\n如：“二手房中介”网站常用的关键词是：“二手房买卖”，“二手房交易”，“二手房过户”，“二手房贷款”等。</p>\n</li>\n<li>\n<p>描述(description)描述的内容应该与正文的内容相关。浏览者可以在搜索结果中阅读相关的描述。控制长度，字符数（含空格）不宜超过200字。可以对title和keywords的内容进行补充。</p>\n</li>\n<li>\n<p>其他meta标签属性:</p>\n<ul>\n<li>none：表示里面的文本内容或链接不可被查询。</li>\n<li>from：表示页面上的链接可被查询。</li>\n<li>nofrom：表示页面上的链接不可被查询。</li>\n<li>author：涉及关于作者版权的搜索。</li>\n<li>content部分常用命令：index、noindex、follow、nofollow，noarchive命令间以英文的“,”分隔。</li>\n<li>index：允许查询、抓取本页。</li>\n<li>follow：允许跟踪链接。</li>\n<li>noindex：禁止查询、抓取本页。</li>\n<li>nofollow：禁止跟踪链接。</li>\n<li>noarchive：防止搜索引擎显示网站快照（网页快照）。</li>\n<li>网站快照：搜索引擎在收录网页时，对网页进行备份，保存在自己（搜索引擎）的服务器缓存里，当用户在搜索引擎中点击“网页快照”链接时，搜索引擎将Spider系统当时所抓取并保存的网页内容展现出来，称为“网页快照”。</li>\n</ul>\n</li>\n</ol>\n<p><strong>例如:</strong></p>\n<ol>\n<li><code>&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt;</code>作用：告诉搜索引擎不要抓取该页，如果该页已经收录，那么删除已经收录页面。</li>\n<li><code>&lt;meta name=&quot;robots&quot; content=&quot;nofollow&quot;&gt;</code>作用：告诉搜索引擎不要跟踪该页所有链接。</li>\n<li><code>&lt;meta name=&quot;robots&quot; content=&quot;noarchive&quot;&gt;</code>作用：告诉搜索引擎不要显示网站快照。<br>\n注意：\n<ul>\n<li><code>meta name=&quot;robots&quot;</code>指所有的搜索引擎的，也可以指定某一个搜索引擎，例如：</li>\n<li><code>meta name=&quot;Googlebot&quot;</code>(谷歌蜘蛛)</li>\n<li><code>meta name=&quot;Baiduspider&quot;</code>(百度蜘蛛)<br>\n另外：</li>\n<li><code>&lt;a rel=“nofollow” href=“url”&gt;</code>作用：告诉搜索引擎不要抓取该链接。</li>\n</ul>\n</li>\n</ol>\n<p><strong>补充：</strong></p>\n<ol>\n<li>\n<p><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//&quot;&gt;</code></p>\n<ul>\n<li>使用原理：在DNS 解析和浏览器加载原理上，解析单个域名同样的地点加上高并发（极端）难免有点堵塞，再加上部分浏览器对相同域名去DNS 解析的时候会异步，导致速度下降，虽然这些速度上咱们可能看不上，但蚊子再小也是肉，优化就讲究极致。DNS Prefetch 是一种DNS 预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS 的解析，减少用户等待时间，提高用户体验。“//” 是为了适配  https 和 http。</li>\n</ul>\n</li>\n<li>\n<p><code>&lt;meta name=&quot;renderer&quot; content=&quot;浏览器内核类型&quot;&gt;</code>：</p>\n<ul>\n<li>用于告诉浏览器默认以哪种浏览器内核浏览当前网站，浏览器就会在读取到这个属性后，会立马切换到对应的模式。</li>\n</ul>\n</li>\n<li>\n<p>content的取值主要有三种浏览器内核，分别是：</p>\n<ol>\n<li>webkit：使用的webkit内核，属于极速模式，常用于网站的高速浏览，网站打开速度快，但某些网站在极速模式下可能出现兼容性问题，显示不正常； 如：<code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></li>\n<li>ie-comp：使用IE兼容模式，就是用IE6，IE7，IE8的渲染模式，网站打开速度比极速模式略低，但网页兼容性问题较少，常用于网银、交易支付、旧版网站；如：<code>&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt;</code></li>\n<li>ie-stand：属于IE标准模式，网站会使用IE9及以上版本的渲染方式渲染，支持硬件加速、支持IE9及以上版本全新的脚本渲染引擎；如：<code>&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt;</code></li>\n</ol>\n</li>\n<li>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;&quot;&gt;</code></p>\n<ol>\n<li>width：控制 viewport 的大小，可以指定的一个值，比如 800，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）</li>\n<li>height：和 width 相对应，指定高度</li>\n<li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例</li>\n<li>maximum-scale：允许用户缩放到的最大比例</li>\n<li>minimum-scale：允许用户缩放到的最小比例</li>\n<li>user-scalable：用户是否可以手动缩放</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"head区的标签注意事项\">head区的标签注意事项</h3>\n<ol>\n<li>title长度：搜索引擎识别20个汉字或60个英文字母内，超出部分会被丢弃。</li>\n<li>title的重要性：网页搜索中最重要的判断依据，是最重要的标签。</li>\n<li>描述和关键词：在搜索结果中展示，其内容关系到能否吸引用户。</li>\n<li>如何写好描述：真实，不浮夸，实事求是，有显著特点。</li>\n<li>关键字标记的禁忌：重复堆砌相同的关键词可以让排名适当靠前，但是也容易受到搜索引擎的惩罚。</li>\n</ol>\n<h3 id=\"body区的组成\">body区的组成</h3>\n<ol>\n<li>\n<p>h标题标签：h1~h6代表段落标题权重的依次递减。<br>\n<strong>如：h1代表网页的主标题，h2代表分段内容的标题，以此类推。即使h6也有一定的权重比，只是比较弱。</strong><br>\n例如：（权重依次递减）</p>\n<blockquote>\n<p>h1：亚洲旅游<br>\nh2：东亚旅游，东南亚旅游<br>\nh3：中国旅游，日本旅游，马来西亚旅游<br>\n…<br>\nh6：金殿旅游，云南野生动物园旅游</p>\n</blockquote>\n</li>\n<li>\n<p>标签的理解：每种标签都有对应的功能，如p标签不能做标题。</p>\n</li>\n<li>\n<p>网页的命名：拼音或者英文单词的命名方式更容易被搜索引擎认可。如：qiche.html  与  123456.html对比，前者更容易被识别，因为其名称本身就是对网站的描述。</p>\n</li>\n<li>\n<p>图片优化：alt=“”,如果图片无法加载，则显示友好提示。title=“”，利于搜索引擎识别。</p>\n</li>\n<li>\n<p><code>&lt;header&gt;&lt;footer&gt;</code>标签的使用，利于搜索引擎自动识别页面内容和布局。</p>\n</li>\n</ol>\n<p><strong>基本格式如下：</strong></p>\n<blockquote>\n<p><code>&lt;head&gt;</code>区域:</p>\n<ol>\n<li>设置合适的<code>&lt;title&gt;</code>：20个汉字以内</li>\n<li>设置<code>&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;</code></li>\n<li>设置<code>&lt;meta name=&quot;description&quot; content=&quot;&quot;/&gt;</code></li>\n<li>如果网站需要，可以写作者：<code>&lt;meta name=&quot;author&quot; content=&quot;&quot; /&gt;</code></li>\n<li>版权设置<code>&lt;meta name=&quot;copyright&quot; content=&quot;&quot; /&gt;</code></li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>&lt;body&gt;</code>区域：</p>\n<ol>\n<li>页面主体设置<code>&lt;h1&gt;</code>标签：主标题</li>\n<li>设置<code>&lt;h2&gt;</code>标签：副标题</li>\n<li>图片的优化：<code>alt=&quot;&quot;， title=&quot;&quot;</code></li>\n<li><code>&lt;header&gt;,&lt;footer&gt;</code>标签的使用</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>网页命名：<br>\n尽量使用拼音或英文，利于搜索引擎识别和网页展示：xxx.html</p>\n</blockquote>\n",
            "tags": [
                "前端设计",
                "单页设计与推广",
                "SEO优化"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/90f8904c.html",
            "url": "https://miraitowa.cc/post/90f8904c.html",
            "title": "互联网网店设计",
            "date_published": "2021-03-02T04:59:28.000Z",
            "content_html": "<h2 id=\"店铺装修基础知识\">店铺装修基础知识</h2>\n<h3 id=\"了解店铺装修的重要性\">了解店铺装修的重要性:</h3>\n<p>网店装修一直是个非常热门的话题，开网店，也要把门面装修得漂亮点才能吸引客人。店铺的第一印象对于人的认知会产生相当的影响，对于网络店铺来说，装修更是店铺兴旺的制胜法宝，任何物品的任何信息我们都只能通过眼球来获得，所以更要在美观上下一些功夫。</p>\n<h3 id=\"做好店铺装修前的准备\">做好店铺装修前的准备:</h3>\n<p>所谓网店装修，就是将原本平淡无奇的页面通过各种图片、动画、文字等元素进行美化，从而使网店变得更生动、形象。在对店铺进行装修前，首先应该做足准备，这样才可以达到事半功倍的效果。</p>\n<ol>\n<li>主营商品的性质</li>\n<li>合适的装修风格</li>\n<li>收集装修素材</li>\n</ol>\n<h2 id=\"商品图片的处理与美化\">商品图片的处理与美化</h2>\n<p>一张好图胜千言，在网络上，买家不能看到商品实物，都是通过图片才能了解商品，因此，如果商品图片制作精良、漂亮，必然会引起买家兴趣。</p>\n<ol>\n<li>调整商品图片的大小</li>\n<li>商品图片的裁剪</li>\n<li>图片的亮度、对比度与颜色调整</li>\n</ol>\n<h2 id=\"店铺公告模板设计\">店铺公告模板设计</h2>\n<p><strong>网店公告显示在普通店铺右上角，店主可以在此发布一些促销、公告信息。</strong></p>\n<h3 id=\"店铺公告的设计原则与要求\">店铺公告的设计原则与要求</h3>\n<p>店铺公告信息是用来显示店铺的动态信息、商品促销、服务信息等内容的，普通店铺公告的位置一般显示在店面的右上角；普通店铺公告的位置、尺寸和播放方式都是固定设置的，只能在有限区域内发挥作用。</p>\n<h3 id=\"定义公告中的文字样式\">定义公告中的文字样式</h3>\n<p>默认情况下，淘宝店铺公告中的文字是黑色的宋体字，可以通过编辑器的方式来对公告文字的字体、字号、颜色等进行设置。</p>\n<h3 id=\"美观的图片形式公告栏的设计\">美观的图片形式公告栏的设计</h3>\n<p>除了简单的文字公告形式外，淘宝店铺还支持使用图片形式的公告，就是将公告制作成一张图片。</p>\n",
            "tags": [
                "前端设计",
                "网店设计"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/db7dc918.html",
            "url": "https://miraitowa.cc/post/db7dc918.html",
            "title": "网站整站交互设计",
            "date_published": "2021-03-01T04:59:28.000Z",
            "content_html": "<h2 id=\"网站设计方法\">网站设计方法</h2>\n<p>简介: 网站设计要能充分吸引访问者的注意力，让访问者产生视觉上的愉悦感。因此在网页创作的时候就必须将网站的整体设计与网页设计的相关原理紧密结合起来。网站设计是将策划案中的内容、网站的主题模式，以及结合自己的认识通过艺术的手法表现出来；而网页制作通常就是将网页设计师所设计出来的设计稿，按照W3C规范用html（标准通用标记语言下的一个应用）将其制作成网页格式。</p>\n<h3 id=\"设计方法\">设计方法:</h3>\n<ol>\n<li>确定网站目标</li>\n<li>满足用户的设计心理</li>\n<li>熟悉和识别模式</li>\n<li>网络上的品牌符号要统一</li>\n<li>心里激发</li>\n<li>运用图像强化概念</li>\n</ol>\n<h2 id=\"网站的可用性\">网站的可用性</h2>\n<h3 id=\"如何判断网页的可用性？\">如何判断网页的可用性？</h3>\n<p><code>页面链接的点击率</code>是判断网站价值的一个指标。因此，可用性测试是否有助于提高网页价值的一个重要判断标准就是：在同等条件下，根据测试结果改进后的网页上的点击率是否也得到相应提升。不可否认，有时网站的商业目的与改善用户体验的测试目的并不完全一致，在项目中我们努力在两者之间寻找平衡点，希望在提升网站用户体验的同时，符合网站给出的判断标准。</p>\n<h3 id=\"如何让提升网站可用性\">如何让提升网站可用性?</h3>\n<ol>\n<li>寻找用户能够理解的方式来表达信息</li>\n<li>让用户能够按照自己认为正确的方式操作</li>\n</ol>\n<h3 id=\"影响网站可用性的关键因素\">影响网站可用性的关键因素:</h3>\n<ol>\n<li>是否直观。衡量新用户是否能不费力的了解该网站的主旨、内容、使用流程;</li>\n<li>是否高效。衡量老用户（明确知道如何使用）使用该网站达成目标的过程是否高效;</li>\n<li>是否容易记忆。衡量老用户（之前仅使用过一次）是否需要在第二次使用时重复探索、学习网站使用流程;</li>\n<li>用户误操作的频率和严重性。衡量用户使用过程中是否经常误操作、这些误操作影响是否严重、用户如何自行纠正这些错误;</li>\n<li>是否满意。用户的主观感受如何，是否对使用该网站达成目标的过程感到满意;</li>\n</ol>\n<h2 id=\"常见网站的错误设计\">常见网站的错误设计</h2>\n<ol>\n<li>搜索引擎不友好</li>\n<li>使用PDF文件做为在线阅读</li>\n<li>未改变已访问链接的颜色</li>\n<li>文字未排版</li>\n<li>固定字体大小</li>\n<li>网页标题搜索引擎不友好</li>\n<li>所有的东西看起来都像广告</li>\n<li>违反设计惯例</li>\n<li>打开新的浏览器窗口</li>\n<li>不回答用户的提问</li>\n</ol>\n",
            "tags": [
                "前端设计",
                "整站交互设计"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/68889350.html",
            "url": "https://miraitowa.cc/post/68889350.html",
            "title": "yarn和npm常用命令",
            "date_published": "2021-01-22T16:00:00.000Z",
            "content_html": "<h2 id=\"yarn和npm常用命令对比\">yarn和npm常用命令对比</h2>\n<table>\n<thead>\n<tr>\n<th>作用</th>\n<th>npm</th>\n<th>yarn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>安装</td>\n<td>npm install/i</td>\n<td>yarn</td>\n</tr>\n<tr>\n<td>卸载</td>\n<td>npm unintall/un xxx</td>\n<td>yarn remove xxx</td>\n</tr>\n<tr>\n<td>全局安装</td>\n<td>npm install/i xxx --global/-g</td>\n<td>yarn global add xxx</td>\n</tr>\n<tr>\n<td>安装包</td>\n<td>npm install/i xxx --save/-S</td>\n<td>yarn add xxx</td>\n</tr>\n<tr>\n<td>开发模式安装包</td>\n<td>npm install/i xxx --save-dev/-D</td>\n<td>yarn add xxx -dev/-D</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>npm update</td>\n<td>yarn upgrade</td>\n</tr>\n<tr>\n<td>全局更新</td>\n<td>npm update -g</td>\n<td>yarn global upgrade</td>\n</tr>\n<tr>\n<td>清除缓存</td>\n<td>npm cache clean</td>\n<td>yarn cache clean</td>\n</tr>\n<tr>\n<td>重装</td>\n<td>rm -rf node_modules &amp;&amp; npm install</td>\n<td>yarn upgrade</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"npm-install-常用命令\">npm install 常用命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install moduleName</td>\n<td>安装模块到项目目录</td>\n</tr>\n<tr>\n<td>npm install -g moduleName</td>\n<td><code>-g</code> 意思是将模块安装到全局</td>\n</tr>\n<tr>\n<td>npm install --save moduleName</td>\n<td><code>--save</code> 的意思是将模块安装到项目目录下，并在package文件的<code>dependencies</code>节点写入依赖。</td>\n</tr>\n<tr>\n<td>npm install --save-dev moduleName</td>\n<td><code>--save-dev</code> 的意思是将模块安装到项目目录下，并在package文件的<code>devDependencies</code>节点写入依赖。</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "npm",
                "yarn"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/643e8ed0.html",
            "url": "https://miraitowa.cc/post/643e8ed0.html",
            "title": "常用的Git操作",
            "date_published": "2021-01-21T05:06:41.000Z",
            "content_html": "<h2 id=\"Git-Push\">Git Push</h2>\n<div class=\"tabs\" id=\"test1\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#test1-1\">方法一</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#test1-2\">方法二</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"test1-1\"><p><strong>此方法适用于已经在Github创建好仓库</strong></p>\n<ul>\n<li>把Github上面的仓库克隆到本地</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/Github用户名/仓库名.git</span><br></pre></td></tr></table></figure>\n<ul>\n<li>进入项目文件夹</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> 项目名</span><br></pre></td></tr></table></figure>\n<ul>\n<li>把文件夹下面的文件都添加进来</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n<ul>\n<li>提交信息</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit <span class=\"literal\">-m</span> <span class=\"string\">&quot;xxxxxx&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>把本地仓库push到github上面，此步骤需要输入帐号和密码</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push <span class=\"literal\">-u</span> origin master(<span class=\"number\">2020</span> 年 <span class=\"number\">10</span> 月 <span class=\"number\">1</span> 日起，在 Github 平台上创建的所有新的源代码仓库将默认命名为 <span class=\"string\">&quot;main&quot;</span> ，不再是原先的 <span class=\"string\">&quot;master&quot;</span> )</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"test1-2\"><p><strong>本方法需要先创建一个本地的版本库</strong></p>\n<ul>\n<li>通过命令行在桌面新建一个test文件夹</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdar test</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过init把这个文件夹变成Git可管理的仓库</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>把你的项目粘贴到这个本地Git仓库里面</p>\n</li>\n<li>\n<p>粘贴后你可以通过<code>git status</code>来查看你当前的状态</p>\n</li>\n<li>\n<p>把刚才复制过来的项目全部添加到仓库</p>\n</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n<ul>\n<li>提交到本地缓冲(注释？)</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit <span class=\"literal\">-m</span> <span class=\"string\">&quot;xxxxxx&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在Github上创建好Git仓库</li>\n<li>将本地仓库的代码提交远程github的仓库</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/Github用户名/仓库名.git</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将远程仓库的代码 push到master分支上</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 由于新建的远程仓库是空的  所以要加上<span class=\"literal\">-u</span>这个参数</span><br><span class=\"line\">git push <span class=\"literal\">-u</span> origin master</span><br><span class=\"line\"></span><br><span class=\"line\">- 等远程仓库里面有了内容之后，下次再从本地库上传内容的时候不需要了</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h2 id=\"Git-版本发布\">Git-版本发布</h2>\n<div class=\"tabs\" id=\"\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#-1\">Git-版本发布</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"-1\"><ul>\n<li>创建Github一个版本发布</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br><span class=\"line\">git tag <span class=\"literal\">-a</span> v1.<span class=\"number\">0.0</span> <span class=\"literal\">-m</span> <span class=\"string\">&quot;xxxxxx&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看某标签的信息</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show v1.<span class=\"number\">0.0</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>推送到远程库</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin v1.<span class=\"number\">0.0</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除标签</li>\n</ul>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag <span class=\"literal\">-d</span> v1.<span class=\"number\">0.0</span></span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>",
            "tags": [
                "Git",
                "Github"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/20d94337.html",
            "url": "https://miraitowa.cc/post/20d94337.html",
            "title": "在昆明，没有一个矮子能笑着走出地铁",
            "date_published": "2021-01-20T04:04:03.000Z",
            "content_html": "<div class=\"note warning flat\"><p>长图预警 长图预警 长图预警</p>\n</div>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img1.jpg\" alt=\"img1\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img2.jpg\" alt=\"img2\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img3.jpg\" alt=\"img3\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img4.jpg\" alt=\"img4\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img5.jpg\" alt=\"img5\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img6.jpg\" alt=\"img6\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img7.jpg\" alt=\"img7\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img8.jpg\" alt=\"img8\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img9.jpg\" alt=\"img9\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img10.jpg\" alt=\"img10\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img11.jpg\" alt=\"img11\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img12.jpg\" alt=\"img12\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img13.jpg\" alt=\"img13\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img14.jpg\" alt=\"img14\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-kunming-subway-img15.jpg\" alt=\"img15\"></p>\n<div class=\"note danger flat\"><p>图源网络</p>\n</div>",
            "tags": [
                "日常",
                "昆明"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/68a0812f.html",
            "url": "https://miraitowa.cc/post/68a0812f.html",
            "title": "butterfly主题魔改记录",
            "date_published": "2021-01-18T05:06:41.000Z",
            "content_html": "<h2 id=\"取其精华\">取其精华</h2>\n<p><strong>2021-01-20</strong></p>\n<ul>\n<li>基于<a href=\"https://www.antmoe.com/posts/a811d614/index.html\">butterfly主题优雅魔改系列</a>进行精简,去除自己不需要的功能。</li>\n</ul>\n<hr>\n<h2 id=\"首页置顶轮播\">首页置顶轮播</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">时间</th>\n<th style=\"text-align:left\">2020-01-18</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>作者</strong></td>\n<td style=\"text-align:left\"><strong><a href=\"https://akilar.top/\">Akilarの糖果屋</a></strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>链接</strong></td>\n<td style=\"text-align:left\"><a href=\"https://akilar.top/posts/8e1264d1/\"><strong>首页置顶轮播图</strong></a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"留言板动态弹出信封样式\">留言板动态弹出信封样式</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>时间</strong></th>\n<th style=\"text-align:left\"><strong>2020-01-17</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>作者</strong></td>\n<td style=\"text-align:left\"><strong><a href=\"https://akilar.top/\">Akilarの糖果屋</a></strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>链接</strong></td>\n<td style=\"text-align:left\"><strong><a href=\"https://akilar.top/posts/f99b208/#%E7%95%99%E8%A8%80%E6%9D%BF%E5%8A%A8%E6%80%81%E5%BC%B9%E5%87%BA%E4%BF%A1%E5%B0%81%E6%A0%B7%E5%BC%8F\">留言板动态弹出信封样式</a></strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"butterfly主题优雅魔改系列\">butterfly主题优雅魔改系列</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>时间</strong></th>\n<th style=\"text-align:left\"><strong>2020-01-04</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>作者</strong></td>\n<td style=\"text-align:left\"><strong><a href=\"https://www.antmoe.com/\">小康（Dreamy.TZK）</a></strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>链接</strong></td>\n<td style=\"text-align:left\"><strong><a href=\"https://www.antmoe.com/posts/a811d614/index.html\">butterfly主题优雅魔改系列</a></strong></td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "butterfly",
                "hexo",
                "魔改"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/2b43fca2.html",
            "url": "https://miraitowa.cc/post/2b43fca2.html",
            "title": "怀念-Mc",
            "date_published": "2020-10-26T12:58:03.000Z",
            "content_html": "<p>纪念一下曾经那些无数个孤独生存的日子.</p>\n<p>如今很少有时间能静下心来好好玩一款游戏了。</p>\n<div class=\"justified-gallery\"><p><img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/1603892818463.jpg\" alt=\"\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/mc1.png\" alt=\"\"><br><img src= \"/img/loading.gif\" data-lazy-src=\"https://gitee.com/usocute/gallery/raw/master/img/1603892818469.jpg\" alt=\"\"></p>\n          </div>\n",
            "tags": [
                "MC",
                "Minecrift"
            ]
        }
    ]
}