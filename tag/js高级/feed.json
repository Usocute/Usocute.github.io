{
    "version": "https://jsonfeed.org/version/1",
    "title": "Miraitowa • All posts by \"js高级\" tag",
    "description": "永远期待明亮的未来,一个收藏回忆记录成长的地方...",
    "home_page_url": "https://miraitowa.cc",
    "items": [
        {
            "id": "https://miraitowa.cc/post/7292aa95.html",
            "url": "https://miraitowa.cc/post/7292aa95.html",
            "title": "JavaScript高级⑥-存储(cookie)",
            "date_published": "2021-03-28T10:00:00.000Z",
            "content_html": "<h2 id=\"sessionStorage、localStorage和cookie\">sessionStorage、localStorage和cookie</h2>\n<h3 id=\"相同点\">相同点</h3>\n<ul>\n<li>都是保存在浏览器端、且同源的。</li>\n</ul>\n<h3 id=\"区别\">区别</h3>\n<ol>\n<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。<code>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</code>。</li>\n<li>存储大小限制也不同，<code>cookie数据不能超过4K（小于4096）</code>，同时因为每次http请求都会携带cookie、所以<code>cookie只适合保存很小的数据，如会话标识</code>。<code>sessionStorage和localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到<code>5M或更大</code>。</li>\n<li>数据有效期不同，<code>sessionStorage</code>：仅在<code>当前浏览器窗口关闭之前</code>有效；<code>localStorage</code>：<code>始终有效</code>，窗口或浏览器关闭也一直保存，因此用作持久数据；<code>cookie</code>：只<code>在设置的cookie过期时间之前有效</code>，即使窗口关闭或浏览器关闭。</li>\n<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>\n<li><code>web Storage</code>支持事件通知机制，可以将数据更新的通知发送给监听者。</li>\n<li><code>web Storage</code>的api接口使用更方便。</li>\n<li><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li>\n</ol>\n<h2 id=\"Cookie\">Cookie</h2>\n<ol>\n<li>\n<p>什么是Cookie：cookie是存储于用户计算机中的变量。每当该计算机通过浏览器请求某个页面时，就会发送这个cookie。我们可以使用JavaScript来创建和获取cookie的值。</p>\n</li>\n<li>\n<p>cookie的存储形式：<code>键值对</code>，如：<code>name=张三</code></p>\n</li>\n<li>\n<p>使用JS创建Cookie的格式：<code>document.cookie = “name=张三”;</code><br>\n还可以为cookie添加一个过期时间（UTC或GMT,默认情况下，cookie在浏览器关闭时删除）。如：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.cookie = “name=张三;</span><br><span class=\"line\">expires=Thu, <span class=\"number\">18</span> Dec <span class=\"number\">2019</span> <span class=\"number\">12</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> GMT”;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用JS读取Cookie的格式： <code>var X = document.cookie;</code></p>\n</li>\n<li>\n<p>修改Cookie：JS中修改cookie类似于创建cookie，旧的cookie会被覆盖掉。</p>\n</li>\n<li>\n<p>删除Cookie：只需设置expires参数为以前的时间即可。<br>\n如：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.cookie = “name=张三; </span><br><span class=\"line\">expires=Thu, <span class=\"number\">18</span> Dec <span class=\"number\">2019</span> <span class=\"number\">12</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> GMT”;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Cookie的缺点：</p>\n<ol>\n<li>Cookie可能被用户禁用。</li>\n<li>同一个页面被不同浏览器访问时，浏览器之间保存的Cookie不能相互访问。</li>\n<li>每个Cookie都保存在客户端硬盘文件上，可能会被删除。</li>\n<li>Cookie安全性不高，所有Cookie都是以纯文本形式记录于文件中。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Web存储机制\">Web存储机制</h2>\n<blockquote>\n<ul>\n<li>HTML5提供了一种新的对象<code>Storage</code>，类似于<code>String</code>、<code>Number</code>、<code>Object</code>。通过Storage对象提供的方法和属性来对数据进行增删改查。</li>\n<li>html5中的<code>Web Storage</code>包括了两种存储方式：<code>localStorage</code>和<code>sessionStorage</code>。两者都是用来存储客户端临时信息的对象。</li>\n<li><code>sessionStorage</code>用于本地存储一个会话（<code>session</code>）中的数据，这些数据只有在同一个会话中的页面才能访问，并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅是会话级别的存储。只允许同一窗口访问。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。同源可以读取并修改localStorage数据。并且他们储存的对象类型均为字符串类型；我们将数据以键值对的形式保存到Storage对象里，通过Storage对象提供的方法进行数据操作。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 增：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</span></span><br><span class=\"line\">Storage.setItem()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2. 删</span></span><br><span class=\"line\"><span class=\"comment\">// 清空存储中的所有键名</span></span><br><span class=\"line\">Storage.clear()</span><br><span class=\"line\"><span class=\"comment\">// 接受一个键名作为参数，并把该键名从存储中删除。</span></span><br><span class=\"line\">Storage.removeItem()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 改：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</span></span><br><span class=\"line\">Storage.setItem()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 查</span></span><br><span class=\"line\"><span class=\"comment\">// 接受一个键名作为参数，返回键名对应的值</span></span><br><span class=\"line\">Storage.getItem()</span><br><span class=\"line\"><span class=\"comment\">// 接受一个数值 n 作为参数，并返回存储中索引为n 的键名</span></span><br><span class=\"line\">Storage.key()</span><br><span class=\"line\"><span class=\"comment\">// 返回存储的数据量</span></span><br><span class=\"line\">Storage.length</span><br></pre></td></tr></table></figure>\n<h2 id=\"sessionStorage对象\">sessionStorage对象</h2>\n<ul>\n<li>sessionStorage对象存储某个特定会话的数据，该数据只保持到浏览器关闭（类似于cookie）。</li>\n<li>存储在sessionStorage对象中的数据可以跨越页面刷新而存在。部分浏览器也支持在浏览器崩溃的情况下重启仍然可用（如：Firefox和WebKit等，但是IE不支持）。</li>\n<li>sessionStorage对象其实是Storage对象的一个实例，具体方法如下：\n<ol>\n<li>sessionStorage.length:获取存储在Storage对象中的数据的数量，是一个只读属性。</li>\n<li>sessionStorage.key():接受一个数值 n 作为参数，并返回存储中索引为n 的键名。</li>\n<li>sessionStorage.getItem():接受一个键名作为参数，返回键名对应的值。</li>\n<li>sessionStorage.setItem()：接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>\n<li>sessionStorage.clear()：清空存储中的所有键名。</li>\n<li>sessionStorage.removeItem()：接受一个键名作为参数，并把该键名从存储中删除。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"globalStorage\">globalStorage</h2>\n<blockquote>\n<p>globalStorage在浏览器关闭以后，使用globalStorage存储的信息仍能够保留下来，localStorage一样，域中任何一个页面存储的信息都能被所有的页面共享。</p>\n</blockquote>\n<ul>\n<li>基本语法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在developer.mozilla.org下面所有的子域都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;developer.mozilla.org&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在mozilla.org域名下面的所有网页都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;mozilla.org&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在.org域名下面的所有网页都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;org&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在任何域名下的任何网页都可以通过这个命名空间存储对象来进行读和写</span></span><br><span class=\"line\">globalStorage[<span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：globalStorage对象已经被localStorage对象取代。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"localStorage对象\">localStorage对象</h2>\n<ul>\n<li>\n<p>localStorage的优势：</p>\n<ol>\n<li>localStorage拓展了cookie的4k限制。</li>\n<li>localStorage可用将第一次请求的数据直接存储到本地，相当于5M大小的针对于前端页面的数据库，相比于cookie可用节约带宽，但是只有在高版本浏览器中才支持。</li>\n</ol>\n</li>\n<li>\n<p>localStorage的局限：</p>\n<ol>\n<li>只有在IE8以上浏览器才支持localStorage的存储功能。</li>\n<li>目前所有浏览器都会把localStorage的值类型限定为string，这需要我们转换为JSON对象类型。</li>\n<li>localStorage在浏览器的隐私模式下不可读取。</li>\n<li>由于localStorage在本质上是对字符串的读取，所以如果存储的内容较多，会消耗掉内存空间，导致页面卡顿，加载速度减慢。</li>\n<li>localStorage不能被爬虫抓取到。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>localStorage对象的具体方法与sessionStorage的方法一致。</p>\n</blockquote>\n",
            "tags": [
                "js",
                "js高级",
                "cookie"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/a1736a1e.html",
            "url": "https://miraitowa.cc/post/a1736a1e.html",
            "title": "JavaScript高级⑤-高级函数",
            "date_published": "2021-03-25T10:00:00.000Z",
            "content_html": "<h2 id=\"安全的类型检测\">安全的类型检测</h2>\n<blockquote>\n<p><code>在JS中，内置的类型检测机制有typeof和instanceof</code>，但是这两个关键字<code>并非完全可靠</code>。所以我们可以使用<code>Object的toString()方法</code>以保证返回一个<code>[object XXX]</code>格式的字符串。这样就可以创建一个函数来判断对象的类型。</p>\n</blockquote>\n<h2 id=\"作用域安全的构造函数\">作用域安全的构造函数</h2>\n<ul>\n<li>创建一个作用域安全的构造函数，就是让this对象指向正确的实例对象。</li>\n<li>首先使用<code>instanceof</code>方法判断this对象是否为正确类型的实例，如果不是，就创建一个新的实例并返回。</li>\n</ul>\n<h2 id=\"惰性载入函数\">惰性载入函数</h2>\n<p><strong>惰性载入函数表示函数执行的分支仅会发生一次，实现惰性载入函数的方式有两种。</strong><br>\n1. 第一种，在函数被调用时再处理。在第一次调用时，该函数会覆盖为另一个按合适方式执行的函数，这样任何对函数的调用都不会再经过执行的分支了。<br>\n2. 第二种，在声明函数时就制定适当的函数。这样在第一次调用函数时就不会损失性能，而在代码首次加载时会损失一点儿性能。</p>\n<h2 id=\"函数绑定\">函数绑定</h2>\n<blockquote>\n<p>JS与DOM交互中经常需要使用函数绑定，定义一个函数然后将其绑定到特定DOM元素或集合的某个事件触发程序上，也经常与事件处理程序一起使用，以便把函数作为变量传递的同时保留代码执行环境。</p>\n</blockquote>\n<h2 id=\"重复的定时器\">重复的定时器</h2>\n<p><strong>我们通常使用<code>setInterval</code>方式来实现时间间隔会出现两个问题：</strong><br>\n1. 某些间隔会被跳过。<br>\n2. 多个定时器的代码执行时，间隔可能会有误差。<br>\n<strong>所以我们可以使用<code>setTimeout</code>方式来完善该功能。</strong></p>\n<h2 id=\"函数节流\">函数节流</h2>\n<ul>\n<li>定时器不仅可以用来定时，还可以用来缓解浏览器的压力。浏览器在执行DOM操作的时候，就会使用更多的内存和CPU。连续使用过多的DOM操作会导致浏览器崩溃。</li>\n<li>函数节流的基本思想就是，某些代码不可以在没有间断的情况下连续重复使用。也就是说，第一次调用函数就创建一个定时器，在指定的时间间隔之后才能再次运行。当第二次调用该函数时，就会清除前一次的定时器并设置一个。目的就是为了保证每次执行函数时有一段时间的间隔。</li>\n</ul>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/faefd80d.html",
            "url": "https://miraitowa.cc/post/faefd80d.html",
            "title": "JavaScript高级④-AJAX与JSON",
            "date_published": "2021-03-22T10:00:00.000Z",
            "content_html": "<h2 id=\"AJAX介绍和创建XHR对象\">AJAX介绍和创建XHR对象</h2>\n<blockquote>\n<p>AJAX:异步 JavaScript 和 XML。简短地说，在不重载整个网页的情况下，AJAX通过后台加载数据，并在网页上进行显示。</p>\n</blockquote>\n<p><strong>AJAX包括以下几个步骤：</strong></p>\n<ol>\n<li>创建AJAX对象；</li>\n<li>发出HTTP请求；</li>\n<li>接收服务器传回的数据；</li>\n<li>更新页面数据；</li>\n</ol>\n<ul>\n<li><strong>Ajax的工作原理如图所示：</strong><br>\n<img src=\"https://gitee.com/usocute/gallery/raw/master/img/miraitowa-javascript-AJAX-JSON-img1.png\" alt=\"AJAX\"></li>\n</ul>\n<blockquote>\n<p>总结：</p>\n</blockquote>\n<ul>\n<li>AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后再进行处理。</li>\n<li><code>AJAX技术的核心就是XMLHttpRequest对象</code>（简称：XHR），这是微软首次引入的一个特性，其他浏览器厂商后来都提供了相同的实现。</li>\n<li>IE5中的XHR对象是通过ActiveX对象实现的，而IE7+及其他标准浏览器都支持原生的XHR对象。</li>\n<li>创建一个XHR对象，也叫做实例化一个XHR对象，因为XMLHttpRequest()是一个构造函数。</li>\n</ul>\n<h2 id=\"XHR的用法介绍\">XHR的用法介绍</h2>\n<ol>\n<li><code>open()</code>方法：设置:  HTTP方法和要获取资源的URL;</li>\n<li><code>send()</code>方法：发送请求：</li>\n<li><code>onload</code>属性：设置:  成功获取数据后将要运行的函数;</li>\n<li><code>onerror</code>属性：设置:  出现错误后将要运行的函数;</li>\n<li><code>responseText</code>属性：设置:  存储异步请求响应的文本;</li>\n</ol>\n<h2 id=\"HTTP头部信息\">HTTP头部信息</h2>\n<blockquote>\n<p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。XHR对象也提供了操作这两种头部信息（请求头和响应头）的方法。</p>\n</blockquote>\n<ol>\n<li><code>Accep</code>t：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</li>\n<li><code>Accept-Charset</code>：浏览器告诉服务器自己能接收的字符集。</li>\n<li><code>Accept-Encoding</code>：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）。</li>\n<li><code>Accept-Language</code>：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</li>\n<li><code>Cache-Control</code>：指定请求和响应遵循的缓存机制。</li>\n<li><code>Connection</code>：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1，它就表示持久连接。</li>\n<li><code>Cookie</code>：当前域名下的Cookie。</li>\n<li><code>Referer</code>： 浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL。</li>\n<li><code>User-Agent</code>：浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0</li>\n</ol>\n<h2 id=\"GET与POST请求\">GET与POST请求</h2>\n<ol>\n<li>由于<code>GET方式</code>在发送数据时是将参数拼接在URL上，<code>传输数据会受到URL长度的限制</code>，不同浏览器的长度限制不一样，所以<code>GET方式会受到参数大小的限制</code>，但是<code>POST方式没有参数大小的限制</code>。</li>\n<li>因为GET方式会将请求参数显示在地址栏上，而POST方式不会，所以<code>POST方式相对来讲更安全</code>。</li>\n<li><code>GET方式有缓存，而POST方式没有缓存</code>。</li>\n</ol>\n<h2 id=\"JavaScript中的跨域请求\">JavaScript中的跨域请求</h2>\n<ul>\n<li>受JS同源策略的影响，当在某一域名下请求其他域名，或在同一域名下请求不同端口的URL时，就会变成不被允许的跨域请求。127.0.0.1:8020</li>\n</ul>\n<h2 id=\"了解XDomainRequest对象\">了解XDomainRequest对象</h2>\n<blockquote>\n<p><code>XDomainRequest表示JavaScript和Ajax的跨域请求，在IE8+可以使用</code>。<br>\nXDomainRequest包含以下几个部分：</p>\n</blockquote>\n<ol>\n<li>事件\n<ol>\n<li><code>onload</code>事件：请求成功并返回对象时，被触发。</li>\n<li><code>onerror</code>事件：当跨域请求发生错误时，被触发。</li>\n<li><code>onprogress</code>事件：浏览器开始从服务器端接收数据时，被触发。</li>\n<li><code>ontimeout</code>事件：出现超时情况，被触发。</li>\n</ol>\n</li>\n<li>方法\n<ol>\n<li><code>abort</code>方法：终止等待send</li>\n<li><code>open(XDomainRequest)</code>方法：建立与服务器的链接</li>\n<li><code>send(XDomainRequest)</code>方法：传输一个字符串数据给服务器处理</li>\n</ol>\n</li>\n<li>属性\n<ol>\n<li><code>constructor</code>属性：返回一个对象的构造函数的引用</li>\n<li><code>contentType</code>属性：返回html请求或返回头部的content-type属性</li>\n<li><code>responseText</code>属性：以字符串形式返回请求的body内容</li>\n<li><code>timeout</code>属性：超时后返回的值。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"JSON数据\">JSON数据</h2>\n<blockquote>\n<p><code>JSON(JavaScript Object Notation</code>, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 <code>ECMAScript</code> (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>\n</blockquote>\n<p><strong>Json的语法可以表示成三种类型的值：</strong><br>\n1. 简单值：可以在Json中表示字符串、数值、布尔值和null，但是<code>不支持undefined</code>;<br>\n2. 对象：作为一种复杂数据结构，表示一种无序的键值对，每个键值对中的值既可以是简单值，也可以是复杂数据类型的值。<br>\n3. 数组：作为一种复杂数据结构，表示一种有序值的列表，可以通过数组索引访问其中的值。数组中的元素可以是任何类型：简单值、对象、数组均可。<br>\n<strong>如：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"attr\">b</span>: <span class=\"string\">&#x27;World&#x27;</span>&#125;; </span><br><span class=\"line\"><span class=\"comment\">//这是一个对象，注意键名也是可以使用引号包裹的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"string\">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>;</span><br><span class=\"line\"> <span class=\"comment\">//这是一个 JSON 字符串，本质是一个字符串</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在Ajax中使用JSON数据\">在Ajax中使用JSON数据</h2>\n<ol>\n<li><code>JSON.parse()</code>：把Json格式的字符串转换为Json对象。</li>\n<li><code>JSON.stringify()</code>:把Json对象转换为Json格式的字符串。</li>\n</ol>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/bd399257.html",
            "url": "https://miraitowa.cc/post/bd399257.html",
            "title": "JavaScript高级③-匿名函数及函数操作",
            "date_published": "2021-03-20T10:00:00.000Z",
            "content_html": "<h2 id=\"匿名函数\">匿名函数</h2>\n<h3 id=\"工厂模式\">工厂模式</h3>\n<blockquote>\n<p>假如我们把猫看成是一类，都有名字和颜色的属性，那么，每一只猫就是这个类的实例，我们可以使用字面量方式定义对象：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat1 = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">&quot;大黄&quot;</span>,</span><br><span class=\"line\">  color:<span class=\"string\">&quot;黄色&quot;</span>,</span><br><span class=\"line\">  say:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">&quot;小黑&quot;</span>,</span><br><span class=\"line\">  color:<span class=\"string\">&quot;黑色&quot;</span>,</span><br><span class=\"line\">  say:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这样创建对象，一是创建对象比较麻烦，二是实例与原型（猫类）之间，没有任何联系。</li>\n<li>为了简化代码书写，我们可以写一个函数批量创建对象，也就是使用<code>“工厂模式”</code>：<br>\n<strong>（工厂模式中的函数，首字母大写）：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n,c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name:n,</span><br><span class=\"line\">        color:c,</span><br><span class=\"line\">        say:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>生成实例对象，就等于是在调用函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat1 = Cat(<span class=\"string\">&quot;大黄&quot;</span>,<span class=\"string\">&quot;黄色&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = Cat(<span class=\"string\">&quot;小黑&quot;</span>,<span class=\"string\">&quot;黑色&quot;</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样代码虽然简单了，但是实例之间还是没有什么联系。</p>\n</blockquote>\n<h3 id=\"构造函数\">构造函数</h3>\n<ul>\n<li>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</li>\n<li>所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</li>\n<li>构造函数首字母大写，没有return语句，没有显式地创建对象。</li>\n<li>构造函数中的this，指向的是实例化的对象<br>\n<strong>例如：</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">n,c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name=n;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color=c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成实例对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">&quot;大黄&quot;</span>,<span class=\"string\">&quot;黄色&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat2 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">&quot;小黑&quot;</span>,<span class=\"string\">&quot;黑色&quot;</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(cat1.constructor == Cat); <span class=\"comment\">//true</span></span><br><span class=\"line\">alert(cat2.constructor == Cat); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</li>\n<li>instanceof不认为基本类型值的变量是对象。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> txt=<span class=\"string\">&#x27;adsdf&#x27;</span>;</span><br><span class=\"line\">alert(txt <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>);<span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> age=<span class=\"number\">123123</span>;</span><br><span class=\"line\">alert(age <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span>);<span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> re=<span class=\"regexp\">/\\d/</span>;</span><br><span class=\"line\">alert(re <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr=[];</span><br><span class=\"line\">alert(arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>)<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原型模式和原型链\">原型模式和原型链</h3>\n<ul>\n<li>每类对象的实例对象，都有可能会有一些相同的属性，或者相同的功能，如果都写在构造函数上，会造成重复的内容，占用更多的内存。</li>\n<li>为了解决这种代码的重复</li>\n<li>构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</li>\n<li>我们可以把那些不变的属性和方法，直接定义在prototype对象上。让实例对象共享其属性和方法。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cat.protoType.say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">&quot;miao&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cat1.say()<span class=\"comment\">//miao</span></span><br><span class=\"line\">cat2.say()<span class=\"comment\">//miao</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有的函数都是 Function 的实例。在构造函数上都有一个原型属性—prototype，prototype也是一个对象；这个对象上有一个 constructor 属性，该属性指向的就是构造函数。</li>\n<li>而实例对象上有一个_proto_属性，该属性也指向原型对象，该属性不是标准属性，不可以用在编程中，该属性用于浏览器内部使用。</li>\n</ul>\n<h3 id=\"组合使用构造函数模式和原型模式\">组合使用构造函数模式和原型模式</h3>\n<ol>\n<li>\n<p>构造函数与原型模式组合的模式是目前使用最广泛、认同度最高的一种创建定义类型的方法。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。</p>\n</li>\n<li>\n<p>每个实例都会有自己的一份实例属性的副本，同时共享着对方法的引用，最大限度节省内存。同时，这种组合模式还支持向构造函数传递参数，集合了两种模式的优点。</p>\n</li>\n</ol>\n<h3 id=\"动态原型模式\">动态原型模式</h3>\n<ul>\n<li>动态原型模式就是把所有信息都封装在构造函数中，通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</li>\n</ul>\n<h3 id=\"寄生构造函数模式\">寄生构造函数模式</h3>\n<ul>\n<li>寄生构造函数模式的基本思想，是创建一个用于封装创建对象的函数。主要用于创建一个自定义类型的函数。</li>\n</ul>\n<h3 id=\"稳妥构造函数模式\">稳妥构造函数模式</h3>\n<ul>\n<li>稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。适合在一些安全的环境中（禁用this和new的环境），或者防止数据被其他应用程序调用时使用。</li>\n<li>稳妥构造函数遵循与寄生构造函数类似的模式，只是有两点不同：\n<ol>\n<li>新创建对象的实例方法不引用this；</li>\n<li>不使用new调用构造函数。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"原型链\">原型链</h3>\n<ul>\n<li>原型链可以简单理解为原型组成的链，对象的_proto_就是其原型，而原型也是一个对象，也有_proto_属性。原型的_proto_又是原型的原型，这样可以一直向上找，直到找到Object的原型，就是这条原型链的顶端。</li>\n</ul>\n<h3 id=\"借用构造函数，也称伪造对象或经典继承\">借用构造函数，也称伪造对象或经典继承</h3>\n<ul>\n<li>\n<p>借用构造函数实现继承的基本思想是：在子类的构造函数中调用超类的构造函数。该函数可以通过apply()方法和call()方法在新创建的对象中执行构造函数。</p>\n<blockquote>\n<ul>\n<li>优点：相对于原型链而言，借用构造函数可以在子类构造函数中向超类构造函数传递数据。</li>\n<li>缺点：构造函数的方法都在构造函数中定义，因此无法实现函数复用。另外，子类无法看见在超类中定义的方法，导致所有类型只能使用构造函数模式。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"组合继承\">组合继承</h3>\n<ul>\n<li>组合继承，又称为伪经典继承。指：将原型链和借用构造函数的技术组合在一起，从而发挥两者长处的一种继承模式。\n<blockquote>\n<p>其思想是：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。这样，我们就可以实现通过在原型上定义方法进而实现函数复用，又能保证每个实例都有自己的属性，解决原型链中存在的引用类型属性共享问题。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"原型式继承\">原型式继承</h3>\n<ul>\n<li>原型式继承，即：一个构造方法，通过原型链的方式继承另一个构造函数。</li>\n</ul>\n<h3 id=\"寄生式继承\">寄生式继承</h3>\n<ul>\n<li>寄生式继承，即：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回该对象。</li>\n</ul>\n<h3 id=\"寄生组合式继承\">寄生组合式继承</h3>\n<ul>\n<li>寄生组合式继承是JS最常用的继承模式，其最大的问题就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类原型时，另一次是在子类构造函数内部。</li>\n</ul>\n<h2 id=\"函数操作\">函数操作</h2>\n<h3 id=\"函数表达式\">函数表达式</h3>\n<blockquote>\n<p>使用函数表达式创建的函数，必须先赋值再调用。（即：只有函数声明式才有函数提升，函数表达式没有函数提升。）</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn2(); <span class=\"comment\">// 不能在函数之前调用。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;2.演示函数表达式&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn2(); <span class=\"comment\">// 只能在函数之前调用。</span></span><br></pre></td></tr></table></figure>\n<p><strong>虽然函数表达式没有函数提升，但是它也有自己的一些优点。</strong></p>\n<h2 id=\"递归函数\">递归函数</h2>\n<ul>\n<li>\n<p>递归函数，就是在函数体内调用本函数。最简单的例子就是计算阶乘： 1<em>2</em>3…。</p>\n</li>\n<li>\n<p>递归的缺点：如果递归函数的终止条件不明确甚至缺失，会导致该函数长时间运行，使用户界面处于假死状态。另外，当递归使用太多甚至超过最大调用栈内存容量时，浏览器会报错。</p>\n</li>\n</ul>\n<h3 id=\"闭包\">闭包</h3>\n<ul>\n<li>闭包，是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另一个函数。</li>\n<li>JS中，一般为了给某个函数声明一些只有该函数才能使用的局部变量时就会使用闭包，这样可以减少全局作用域中的变量，净化全局作用域。但是闭包会占用更多的内存。</li>\n</ul>\n<h2 id=\"模仿块级作用域\">模仿块级作用域</h2>\n<ul>\n<li><strong>JS中没有块级作用域，我们可以进行模仿块级作用域。</strong></li>\n</ul>\n<blockquote>\n<p>使用方式：<br>\n简单来讲，就是定义并立即调用一个匿名函数。<br>\n具体步骤，就是将匿名函数声明（函数表达式）在一对圆括号中，而紧随其后的一对圆括号会立即调用该函数。</p>\n</blockquote>\n<h3 id=\"私有变量\">私有变量</h3>\n<ul>\n<li>严格来讲，JS中没有私有成员的概念，所有对象属性都是公开的。</li>\n<li>但是，任何在函数中定义的变量都可以认为是私有变量，因为不能在函数外部访问。</li>\n<li>私有变量包括函数参数，局部变量以及在函数内部定义的其他函数。</li>\n<li>闭包函数可以持有这些私有变量，并在外部访问。</li>\n</ul>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/fec01c07.html",
            "url": "https://miraitowa.cc/post/fec01c07.html",
            "title": "JavaScript高级②-面向对象的程序设计",
            "date_published": "2021-03-19T10:00:00.000Z",
            "content_html": "<p><strong><code>JavaScript是基于对象编程的</code>，<code>面向对象是一种编程思想</code>。</strong></p>\n<h2 id=\"类和对象\">类和对象</h2>\n<ol>\n<li>类：我们善于将事物进行分类，类是一个抽象的概念。</li>\n<li>对象：具体的事物。\n<ul>\n<li>猫是一类</li>\n<li>楼下的大黄  —&gt;  对象</li>\n</ul>\n</li>\n<li>类是对象的抽象，对象是类的具体事例。</li>\n<li>类不占用内存，对象占用内存空间。</li>\n</ol>\n<h2 id=\"Object类型\">Object类型</h2>\n<ul>\n<li>Object对象，是所有JavaScript对象的超类（基类）。</li>\n<li>Object.prototype（Object的原型）定义了JS对象的基本方法和属性。</li>\n</ul>\n<h3 id=\"声明对象-Object变量定义-两种方法\">声明对象(Object变量定义) 两种方法</h3>\n<ul>\n<li>字面量声明 var obj = {};</li>\n<li>new运算符 var obj = new Object();</li>\n</ul>\n<h3 id=\"对象类型的判断\">对象类型的判断</h3>\n<ul>\n<li><code>console.log(typeof  obj);</code></li>\n</ul>\n<h3 id=\"添加对象属性的方法\">添加对象属性的方法</h3>\n<ol>\n<li>语法 ：<a href=\"http://obj.id\">obj.id</a> = “abc”;</li>\n<li>[ ]方括号语法：  obj[“id”]= “abc”;</li>\n</ol>\n<h3 id=\"删除对象属性的方法\">删除对象属性的方法</h3>\n<ul>\n<li>delete <a href=\"http://obj.id\">obj.id</a>;</li>\n<li>delete obj[“id”];</li>\n</ul>\n<h3 id=\"遍历对象\">遍历对象</h3>\n<ul>\n<li>for in 循环</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">&quot;zhangsan&quot;</span>,</span><br><span class=\"line\">  age:<span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key,obj[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//name zhangsan</span></span><br><span class=\"line\"><span class=\"comment\">//age 20</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"检测对象有没有某个属性\">检测对象有没有某个属性</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&quot;name&quot;</span> <span class=\"keyword\">in</span> obj)         （判断有）</span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj.name === <span class=\"literal\">undefined</span>)（判断没有）</span><br></pre></td></tr></table></figure>\n<h2 id=\"Function类型\">Function类型</h2>\n<blockquote>\n<p>Function类型是JS中的引用类型之一，每个函数实际上都是Function类型的实例对象，具有自己的属性和方法。正因为函数式对象，所以函数名实际上也是一个指向函数对象的指针。</p>\n</blockquote>\n<h3 id=\"函数的定义方式\">函数的定义方式</h3>\n<ol>\n<li>使用function关键字定义函数：（函数声明式）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>通过变量声明（表达式）定义函数：（函数表达式）</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数的调用\">函数的调用</h3>\n<ol>\n<li>通过函数名调用： <code>sum()</code>;</li>\n<li>事件绑定调用：   <code>obj.onclick = sum</code>;<br>\n<strong>注意：函数名仅仅保存指向函数对象的指针，隐藏函数名与包含对象指针的其他变量一样。也就是说，一个函数对象可以有多个名字。</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如：<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( sum(<span class=\"number\">5</span>,<span class=\"number\">10</span>) );   <span class=\"comment\">// 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 变量sum2也指向了同一个函数对象   </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum2 = sum;<span class=\"comment\">// sum后面不加括号，不传参数。</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( sum2(<span class=\"number\">3</span>,<span class=\"number\">5</span>) );   <span class=\"comment\">// 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">sum = <span class=\"literal\">null</span>;<span class=\"comment\">// sum对象不再保存函数对象的指针了</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( sum2(<span class=\"number\">3</span>,<span class=\"number\">5</span>) );   <span class=\"comment\">// sum2这个变量仍能继续使用</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数的重载\">函数的重载</h2>\n<blockquote>\n<p>所谓重载，就是一组相同的函数名，有不同个数的参数，在使用时调用一个函数名，传入不同参数，根据你的参数个数，来决定使用不同的函数！但是JS中是没有重载的，因为后定义的函数会覆盖前面的同名函数。<br>\n<strong>在JS中，我们实现重载的常用方式有：</strong></p>\n</blockquote>\n<ol>\n<li>根据传入参数的不同类型进行重载；</li>\n<li>利用参数中特殊的参数值进行重载；</li>\n<li>根据参数的个数进行重载（最简单的方式：switch case 用法）</li>\n</ol>\n<h2 id=\"函数声明式，函数表达式与函数提升\">函数声明式，函数表达式与函数提升</h2>\n<ol>\n<li>\n<p>JS中的声明函数的方法有两种：函数声明式和函数表达式。</p>\n<blockquote>\n<p><strong>两者区别如下：</strong></p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>函数声明式必须要有函数名</code>，而函数表达式的<code>函数名</code>是<code>可选</code>的。</li>\n<li>以<code>函数声明式</code>定义的函数<code>可以在其声明之前被调用</code>，而以<code>函数表达式</code>声明的函数<code>只能在其后被调用</code>。</li>\n<li>以<code>函数声明式</code>定义的函数<code>仅仅可以出现在全局中，或者嵌套在其他函数中</code>，<code>不能出现在循环语句</code>，条件语句和try/catch/finally中；而<code>函数表达式可以在任何地方声明</code>。</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>函数提升</p>\n<blockquote>\n<p>函数提升，即：自动把函数的作用范围提升到全局中。而<code>只有函数声明式才存在函数提升</code>。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"函数内部属性：arguments-this\">函数内部属性：arguments, this</h2>\n<ol>\n<li><code>arguments</code>：用来存放传输参数的数组，可以被调用多次，每次数组都不一样。</li>\n<li><code>this</code>：<code>谁调用函数，谁就是this</code>。进行方法调用的时候函数前面是有window的，只是通常会省略掉。</li>\n</ol>\n<h2 id=\"函数的属性和方法\">函数的属性和方法</h2>\n<ol>\n<li>\n<p><code>length</code>属性</p>\n<blockquote>\n<p>arguments对象的length属性表示实参个数，函数的length属性则表示形参个数。</p>\n</blockquote>\n</li>\n<li>\n<p><code>name</code>属性：访问到给定函数指定的名字，即：跟在function关键字后的标识符。<code>匿名函数的name属性为空</code>。</p>\n</li>\n<li>\n<p><code>prototype</code>属性：是每个函数都有的属性，该属性指向一个对象的引用，这个对象称作<code>原型对象（prototype object）</code>。每一个函数都包含不同的原型对象。将函数用做构造函数时，新创建的对象会从原型对象中继承属性。</p>\n</li>\n<li>\n<p><code>apply()</code>方法和<code>call()</code>方法：是每个函数都有的方法，等同于函数体内this对象的值。（后面讲解）</p>\n</li>\n</ol>\n<h2 id=\"基本包装类型\">基本包装类型</h2>\n<blockquote>\n<p>为了便于操作基本类型的值，ECMAScript提供了3种特殊的引用类型：<code>Boolean</code>, <code>Number</code>, <code>String</code>。他们与其他引用类型的使用方法相似，同时也具有各自的基本类型的属性。实际上，每当读取一个基本类型的值，后台就会创建一个对应的基本包装类型的对象，从而可以调用对应的方法。</p>\n</blockquote>\n<ol>\n<li><code>Boolean</code>类型：没有特定的属性和方法。</li>\n<li><code>Number</code>类型：有静态属性，可以直接调用里面的属性和方法，<code>无需new出来</code>。</li>\n<li><code>String</code>类型：包含String对象属性，字符串方法，字符串操作方法，字符串位置方法等。</li>\n</ol>\n<h2 id=\"JS内置对象介绍\">JS内置对象介绍</h2>\n<ol>\n<li>String对象：字符串对象</li>\n<li>Array对象：数组对象</li>\n<li>Date对象：日期时间对象</li>\n<li>Boolean对象：布尔对象</li>\n<li>Number对象：数值对象</li>\n<li>Math对象：数学对象</li>\n<li>RegExp对象：正则对象</li>\n</ol>\n",
            "tags": [
                "js",
                "js高级"
            ]
        },
        {
            "id": "https://miraitowa.cc/post/4f09663b.html",
            "url": "https://miraitowa.cc/post/4f09663b.html",
            "title": "JavaScript高级①-变量、作用域和内存",
            "date_published": "2021-03-16T10:00:00.000Z",
            "content_html": "<h2 id=\"掌握基本类型和引用类型的值\">掌握基本类型和引用类型的值</h2>\n<ol>\n<li>ECMAScript的数据类型包括两种：基本数据类型和引用数据类型。</li>\n<li>基本数据类型指的是简单的数据段，常见的基本数据类型有： number, string, boolean, null, undefined。</li>\n<li>引用数据类型指的是由多个值构成的对象，常见的引用数据类型（即：对象类型Object type）有： Object, Array, Function, Date等。</li>\n<li>当我们对变量赋值时，解析器首先要确认的就是这个值是基本类型值，还是引用类型值。</li>\n<li>两种数据类型的区别点如下：\n<ul>\n<li>声明变量时不同的内存分配。基本类型的值保存在栈内存中，引用类型的值同时保存在栈内存和堆内存中。</li>\n<li>不同的内存分配机制也带来了不同的访问机制。</li>\n<li>赋值变量时的不同。不能给基本类型的值添加属性。</li>\n<li>参数传递的不同（把实参赋值给形参的过程）。</li>\n</ul>\n</li>\n<li>值的比较：\n<ul>\n<li>基本类型的比较是值的比较；</li>\n<li>引用类型的比较是引用的比较；</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"执行环境及作用域\">执行环境及作用域</h2>\n<ol>\n<li>\n<p>执行环境介绍</p>\n<blockquote>\n<p>执行环境是JavaScript中最重要的一个概念。执行函数定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)和一个作用域链(scope chain)，环境中定义的所有变量和函数都保存在其变量对象中。<code>执行环境分为两种，即：全局执行环境和函数执行环境</code>。</p>\n</blockquote>\n</li>\n<li>\n<p>全局执行环境</p>\n<blockquote>\n<p>全局执行环境是最外围的一个执行环境，其变量对象就是全局活动对象(window activation object)，全局执行环境直到应用程序退出（例如：关闭网页或浏览器）时才会被销毁。</p>\n</blockquote>\n</li>\n<li>\n<p>函数执行环境</p>\n<blockquote>\n<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数环境就会被推入一个环境栈中。当函数执行完之后，栈将该执行环境弹出，把控制权返回给之前的执行环境。函数执行环境的变量对象是该函数的活动对象(activation object)。</p>\n</blockquote>\n</li>\n<li>\n<p>作用域链</p>\n<blockquote>\n<p>对于每一个执行环境，都会创建一个与之关联的作用域链。每个执行环境的作用域链的前端，始终都是该执行环境的变量对象，对于全局执行环境就相当于window对象，对于函数执行环境就相当于该函数的活动对象；对于全局执行环境，已经是根部，没有后续；对于函数执行环境，其作用域链的后续就是该函数对象的[scope]属性里的作用域链。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"垃圾收集\">垃圾收集</h2>\n<blockquote>\n<p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。<br>\n这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。</p>\n</blockquote>\n<ol>\n<li>\n<p>标记清除：</p>\n<ul>\n<li><code>JavaScript中最常用的垃圾收集方式是标记清除</code>。</li>\n<li>垃圾收集器会在运行的时候给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。</li>\n<li>在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</li>\n<li>最后垃圾收集器完成内存清除的工作，销毁那些带标记的值并回收它们所占用的空间。</li>\n</ul>\n</li>\n<li>\n<p>引用计数：</p>\n<ul>\n<li>引用计数是不太常见的垃圾收集策略。</li>\n<li>引用计数的含义是跟踪记录每个值被引用的次数。</li>\n<li>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，如果该值同时赋给另一个变量，则该值引用次数加1。相反，如果包含对这个值引用的变量又取了另一个值，则该值引用次数减1。</li>\n<li>当这个值引用次数变成0时就说明没有办法再访问该值了，可将其占用的内存空间回收。</li>\n<li>当垃圾收集器下次运行时，就会释放那些引用次数为0的值所占用的内存。</li>\n</ul>\n</li>\n</ol>\n<p><strong>另外，垃圾收集处理方式除了以上两种策略，还可以进行<code>垃圾周期处理</code>和<code>解除引用</code>。</strong></p>\n<ul>\n<li>垃圾周期处理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔周期性地执行这一操作。</li>\n<li>解除引用：对于全局变量，当不再使用时，使用null赋值是一个良好的习惯。</li>\n</ul>\n",
            "tags": [
                "js",
                "js高级"
            ]
        }
    ]
}